{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (SIP, environment) {\n  var DTMF = require('./Session/DTMF')(SIP);\n\n  var RFC4028 = require('./RFC4028')(SIP.Timers);\n\n  var Session,\n      InviteServerContext,\n      InviteClientContext,\n      C = {\n    //Session states\n    STATUS_NULL: 0,\n    STATUS_INVITE_SENT: 1,\n    STATUS_1XX_RECEIVED: 2,\n    STATUS_INVITE_RECEIVED: 3,\n    STATUS_WAITING_FOR_ANSWER: 4,\n    STATUS_ANSWERED: 5,\n    STATUS_WAITING_FOR_PRACK: 6,\n    STATUS_WAITING_FOR_ACK: 7,\n    STATUS_CANCELED: 8,\n    STATUS_TERMINATED: 9,\n    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n    STATUS_EARLY_MEDIA: 11,\n    STATUS_CONFIRMED: 12\n  };\n  /*\n   * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]\n   *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)\n   */\n\n  Session = function Session(mediaHandlerFactory) {\n    this.status = C.STATUS_NULL;\n    this.dialog = null;\n    this.earlyDialogs = {};\n    this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory; // this.mediaHandler gets set by ICC/ISC constructors\n\n    this.hasOffer = false;\n    this.hasAnswer = false; // Session Timers\n\n    this.timers = {\n      ackTimer: null,\n      expiresTimer: null,\n      invite2xxTimer: null,\n      userNoAnswerTimer: null,\n      rel1xxTimer: null,\n      prackTimer: null\n    }; // Session info\n\n    this.startTime = null;\n    this.endTime = null;\n    this.tones = null; // Mute/Hold state\n\n    this.local_hold = false;\n    this.remote_hold = false;\n    this.pending_actions = {\n      actions: [],\n      length: function length() {\n        return this.actions.length;\n      },\n      isPending: function isPending(name) {\n        var idx = 0,\n            length = this.actions.length;\n\n        for (idx; idx < length; idx++) {\n          if (this.actions[idx].name === name) {\n            return true;\n          }\n        }\n\n        return false;\n      },\n      shift: function shift() {\n        return this.actions.shift();\n      },\n      push: function push(name) {\n        this.actions.push({\n          name: name\n        });\n      },\n      pop: function pop(name) {\n        var idx = 0,\n            length = this.actions.length;\n\n        for (idx; idx < length; idx++) {\n          if (this.actions[idx].name === name) {\n            this.actions.splice(idx, 1);\n            length--;\n            idx--;\n          }\n        }\n      }\n    };\n    this.early_sdp = null;\n    this.rel100 = SIP.C.supported.UNSUPPORTED;\n  };\n\n  Session.prototype = {\n    dtmf: function dtmf(tones, options) {\n      var tone,\n          dtmfs = [],\n          self = this;\n      options = options || {};\n\n      if (tones === undefined) {\n        throw new TypeError('Not enough arguments');\n      } // Check Session Status\n\n\n      if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      } // Check tones\n\n\n      if (typeof tones !== 'string' && typeof tones !== 'number' || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n        throw new TypeError('Invalid tones: ' + tones);\n      }\n\n      tones = tones.toString().split('');\n\n      while (tones.length > 0) {\n        dtmfs.push(new DTMF(this, tones.shift(), options));\n      }\n\n      if (this.tones) {\n        // Tones are already queued, just add to the queue\n        this.tones = this.tones.concat(dtmfs);\n        return this;\n      }\n\n      var sendDTMF = function sendDTMF() {\n        var dtmf, timeout;\n\n        if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n          // Stop sending DTMF\n          self.tones = null;\n          return this;\n        }\n\n        dtmf = self.tones.shift();\n\n        if (tone === ',') {\n          timeout = 2000;\n        } else {\n          dtmf.on('failed', function () {\n            self.tones = null;\n          });\n          dtmf.send(options);\n          timeout = dtmf.duration + dtmf.interToneGap;\n        } // Set timeout for the next tone\n\n\n        SIP.Timers.setTimeout(sendDTMF, timeout);\n      };\n\n      this.tones = dtmfs;\n      sendDTMF();\n      return this;\n    },\n    bye: function bye(options) {\n      options = Object.create(options || Object.prototype);\n      var statusCode = options.statusCode; // Check Session Status\n\n      if (this.status === C.STATUS_TERMINATED) {\n        this.logger.error('Error: Attempted to send BYE in a terminated session.');\n        return this;\n      }\n\n      this.logger.log('terminating Session');\n\n      if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n        throw new TypeError('Invalid statusCode: ' + statusCode);\n      }\n\n      options.receiveResponse = function () {};\n\n      return this.sendRequest(SIP.C.BYE, options).terminated();\n    },\n    refer: function refer(target, options) {\n      options = options || {};\n      var extraHeaders = (options.extraHeaders || []).slice(),\n          withReplaces = target instanceof SIP.InviteServerContext || target instanceof SIP.InviteClientContext,\n          originalTarget = target;\n\n      if (target === undefined) {\n        throw new TypeError('Not enough arguments');\n      } // Check Session Status\n\n\n      if (this.status !== C.STATUS_CONFIRMED) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      } // transform `target` so that it can be a Refer-To header value\n\n\n      if (withReplaces) {\n        //Attended Transfer\n        // B.transfer(C)\n        target = '\"' + target.remoteIdentity.friendlyName + '\" ' + '<' + target.dialog.remote_target.toString() + '?Replaces=' + target.dialog.id.call_id + '%3Bto-tag%3D' + target.dialog.id.remote_tag + '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';\n      } else {\n        //Blind Transfer\n        // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n        // so try to make one ahead of time\n        try {\n          target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n        } catch (e) {\n          this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n          this.logger.debug(\"...falling through to normalizeTarget()\");\n        } // Check target validity\n\n\n        target = this.ua.normalizeTarget(target);\n\n        if (!target) {\n          throw new TypeError('Invalid target: ' + originalTarget);\n        }\n      }\n\n      extraHeaders.push('Contact: ' + this.contact);\n      extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n      extraHeaders.push('Refer-To: ' + target); // Send the request\n\n      this.sendRequest(SIP.C.REFER, {\n        extraHeaders: extraHeaders,\n        body: options.body,\n        receiveResponse: function (response) {\n          if (!/^2[0-9]{2}$/.test(response.status_code)) {\n            return;\n          } // hang up only if we transferred to a SIP address\n\n\n          if (withReplaces || target.scheme && target.scheme.match(\"^sips?$\")) {\n            this.terminate();\n          }\n        }.bind(this)\n      });\n      return this;\n    },\n    followRefer: function followRefer(callback) {\n      return function referListener(callback, request) {\n        // open non-SIP URIs if possible and keep session open\n        var referTo = request.parseHeader('refer-to');\n        var target = referTo.uri;\n\n        if (!target.scheme.match(\"^sips?$\")) {\n          var targetString = target.toString();\n\n          if (typeof environment.open === \"function\") {\n            environment.open(targetString);\n          } else {\n            this.logger.warn(\"referred to non-SIP URI but `open` isn't in the environment: \" + targetString);\n          }\n\n          return;\n        }\n\n        var extraHeaders = [];\n        /* Copy the Replaces query into a Replaces header */\n\n        /* TODO - make sure we don't copy a poorly formatted header? */\n\n        var replaces = target.getHeader('Replaces');\n\n        if (replaces !== undefined) {\n          extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));\n        } // don't embed headers into Request-URI of INVITE\n\n\n        target.clearHeaders();\n        /*\n          Harmless race condition.  Both sides of REFER\n          may send a BYE, but in the end the dialogs are destroyed.\n        */\n\n        var getReferMedia = this.mediaHandler.getReferMedia;\n        var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;\n        SIP.Hacks.Chrome.getsConfusedAboutGUM(this);\n        var referSession = this.ua.invite(target, {\n          media: mediaHint,\n          params: {\n            to_displayName: referTo.friendlyName\n          },\n          extraHeaders: extraHeaders\n        });\n        callback.call(this, request, referSession);\n        this.terminate();\n      }.bind(this, callback);\n    },\n    sendRequest: function sendRequest(method, options) {\n      options = options || {};\n      var self = this;\n      var request = new SIP.OutgoingRequest(method, this.dialog.remote_target, this.ua, {\n        cseq: options.cseq || (this.dialog.local_seqnum += 1),\n        call_id: this.dialog.id.call_id,\n        from_uri: this.dialog.local_uri,\n        from_tag: this.dialog.id.local_tag,\n        to_uri: this.dialog.remote_uri,\n        to_tag: this.dialog.id.remote_tag,\n        route_set: this.dialog.route_set,\n        statusCode: options.statusCode,\n        reasonPhrase: options.reasonPhrase\n      }, options.extraHeaders || [], options.body);\n      new SIP.RequestSender({\n        request: request,\n        onRequestTimeout: function onRequestTimeout() {\n          self.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          self.onTransportError();\n        },\n        receiveResponse: options.receiveResponse || function (response) {\n          self.receiveNonInviteResponse(response);\n        }\n      }, this.ua).send(); // Emit the request event\n\n      this.emit(method.toLowerCase(), request);\n      return this;\n    },\n    close: function close() {\n      var idx;\n\n      if (this.status === C.STATUS_TERMINATED) {\n        return this;\n      }\n\n      this.logger.log('closing INVITE session ' + this.id); // 1st Step. Terminate media.\n\n      if (this.mediaHandler) {\n        this.mediaHandler.close();\n      } // 2nd Step. Terminate signaling.\n      // Clear session timers\n\n\n      for (idx in this.timers) {\n        SIP.Timers.clearTimeout(this.timers[idx]);\n      } // Terminate dialogs\n      // Terminate confirmed dialog\n\n\n      if (this.dialog) {\n        this.dialog.terminate();\n        delete this.dialog;\n      } // Terminate early dialogs\n\n\n      for (idx in this.earlyDialogs) {\n        this.earlyDialogs[idx].terminate();\n        delete this.earlyDialogs[idx];\n      }\n\n      this.status = C.STATUS_TERMINATED;\n      delete this.ua.sessions[this.id];\n      return this;\n    },\n    createDialog: function createDialog(message, type, early) {\n      var dialog,\n          early_dialog,\n          local_tag = message[type === 'UAS' ? 'to_tag' : 'from_tag'],\n          remote_tag = message[type === 'UAS' ? 'from_tag' : 'to_tag'],\n          id = message.call_id + local_tag + remote_tag;\n      early_dialog = this.earlyDialogs[id]; // Early Dialog\n\n      if (early) {\n        if (early_dialog) {\n          return true;\n        } else {\n          early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY); // Dialog has been successfully created.\n\n          if (early_dialog.error) {\n            this.logger.error(early_dialog.error);\n            this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n            return false;\n          } else {\n            this.earlyDialogs[id] = early_dialog;\n            return true;\n          }\n        }\n      } // Confirmed Dialog\n      else {\n          // In case the dialog is in _early_ state, update it\n          if (early_dialog) {\n            early_dialog.update(message, type);\n            this.dialog = early_dialog;\n            delete this.earlyDialogs[id];\n\n            for (var dia in this.earlyDialogs) {\n              this.earlyDialogs[dia].terminate();\n              delete this.earlyDialogs[dia];\n            }\n\n            return true;\n          } // Otherwise, create a _confirmed_ dialog\n\n\n          dialog = new SIP.Dialog(this, message, type);\n\n          if (dialog.error) {\n            this.logger.error(dialog.error);\n            this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n            return false;\n          } else {\n            this.to_tag = message.to_tag;\n            this.dialog = dialog;\n            return true;\n          }\n        }\n    },\n\n    /**\n    * Check if Session is ready for a re-INVITE\n    *\n    * @returns {Boolean}\n    */\n    isReadyToReinvite: function isReadyToReinvite() {\n      return this.mediaHandler.isReady() && !this.dialog.uac_pending_reply && !this.dialog.uas_pending_reply;\n    },\n\n    /**\n     * Mute\n     */\n    mute: function mute(options) {\n      var ret = this.mediaHandler.mute(options);\n\n      if (ret) {\n        this.onmute(ret);\n      }\n    },\n\n    /**\n     * Unmute\n     */\n    unmute: function unmute(options) {\n      var ret = this.mediaHandler.unmute(options);\n\n      if (ret) {\n        this.onunmute(ret);\n      }\n    },\n\n    /**\n     * Hold\n     */\n    hold: function hold() {\n      if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      }\n\n      this.mediaHandler.hold(); // Check if RTCSession is ready to send a reINVITE\n\n      if (!this.isReadyToReinvite()) {\n        /* If there is a pending 'unhold' action, cancel it and don't queue this one\n         * Else, if there isn't any 'hold' action, add this one to the queue\n         * Else, if there is already a 'hold' action, skip\n         */\n        if (this.pending_actions.isPending('unhold')) {\n          this.pending_actions.pop('unhold');\n        } else if (!this.pending_actions.isPending('hold')) {\n          this.pending_actions.push('hold');\n        }\n\n        return;\n      } else if (this.local_hold === true) {\n        return;\n      }\n\n      this.onhold('local');\n      this.sendReinvite();\n    },\n\n    /**\n     * Unhold\n     */\n    unhold: function unhold(options) {\n      if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      }\n\n      this.mediaHandler.unhold();\n\n      if (!this.isReadyToReinvite()) {\n        /* If there is a pending 'hold' action, cancel it and don't queue this one\n         * Else, if there isn't any 'unhold' action, add this one to the queue\n         * Else, if there is already a 'unhold' action, skip\n         */\n        if (this.pending_actions.isPending('hold')) {\n          this.pending_actions.pop('hold');\n        } else if (!this.pending_actions.isPending('unhold')) {\n          this.pending_actions.push('unhold');\n        }\n\n        return;\n      } else if (this.local_hold === false) {\n        return;\n      }\n\n      this.onunhold('local');\n      this.sendReinvite(options);\n    },\n\n    /**\n     * isOnHold\n     */\n    isOnHold: function isOnHold() {\n      return {\n        local: this.local_hold,\n        remote: this.remote_hold\n      };\n    },\n\n    /**\n     * In dialog INVITE Reception\n     * @private\n     */\n    receiveReinvite: function receiveReinvite(request) {\n      var self = this;\n\n      if (!this.mediaHandler.hasDescription(request)) {\n        this.logger.warn('invalid Content-Type');\n        request.reply(415);\n        return;\n      }\n\n      this.mediaHandler.setDescription(request).then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint)).then(function (description) {\n        var extraHeaders = ['Contact: ' + self.contact];\n        request.reply(200, null, extraHeaders, description, function () {\n          self.status = C.STATUS_WAITING_FOR_ACK;\n          self.setInvite2xxTimer(request, description);\n          self.setACKTimer();\n\n          if (self.remote_hold && !self.mediaHandler.remote_hold) {\n            self.onunhold('remote');\n          } else if (!self.remote_hold && self.mediaHandler.remote_hold) {\n            self.onhold('remote');\n          }\n        });\n      }).catch(function onFailure(e) {\n        var statusCode;\n\n        if (e instanceof SIP.Exceptions.GetDescriptionError) {\n          statusCode = 500;\n        } else {\n          self.logger.error(e);\n          statusCode = 488;\n        }\n\n        request.reply(statusCode);\n      });\n    },\n    sendReinvite: function sendReinvite(options) {\n      options = options || {};\n      var self = this,\n          extraHeaders = (options.extraHeaders || []).slice(),\n          eventHandlers = options.eventHandlers || {},\n          succeeded;\n\n      if (eventHandlers.succeeded) {\n        succeeded = eventHandlers.succeeded;\n      }\n\n      this.reinviteSucceeded = function () {\n        SIP.Timers.clearTimeout(self.timers.ackTimer);\n        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n        self.status = C.STATUS_CONFIRMED;\n        succeeded && succeeded.apply(this, arguments);\n      };\n\n      if (eventHandlers.failed) {\n        this.reinviteFailed = eventHandlers.failed;\n      } else {\n        this.reinviteFailed = function () {};\n      }\n\n      extraHeaders.push('Contact: ' + this.contact);\n      extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n      this.receiveResponse = this.receiveReinviteResponse; //REVISIT\n\n      this.mediaHandler.getDescription(self.mediaHint).then(function (description) {\n        self.dialog.sendRequest(self, SIP.C.INVITE, {\n          extraHeaders: extraHeaders,\n          body: description\n        });\n      }, function () {\n        if (self.isReadyToReinvite()) {\n          self.onReadyToReinvite();\n        }\n\n        self.reinviteFailed();\n      });\n    },\n    receiveRequest: function receiveRequest(request) {\n      switch (request.method) {\n        case SIP.C.BYE:\n          request.reply(200);\n\n          if (this.status === C.STATUS_CONFIRMED) {\n            this.emit('bye', request);\n            this.terminated(request, SIP.C.causes.BYE);\n          }\n\n          break;\n\n        case SIP.C.INVITE:\n          if (this.status === C.STATUS_CONFIRMED) {\n            this.logger.log('re-INVITE received');\n            this.receiveReinvite(request);\n          }\n\n          break;\n\n        case SIP.C.INFO:\n          if (this.status === C.STATUS_1XX_RECEIVED || this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK || this.status === C.STATUS_EARLY_MEDIA || this.status === C.STATUS_CONFIRMED || this.dialog) {\n            if (this.onInfo) {\n              return this.onInfo(request);\n            }\n\n            var body,\n                tone,\n                duration,\n                contentType = request.getHeader('content-type'),\n                reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/,\n                reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n            if (contentType) {\n              if (contentType.match(/^application\\/dtmf-relay/i)) {\n                if (request.body) {\n                  body = request.body.split('\\r\\n', 2);\n\n                  if (body.length === 2) {\n                    if (reg_tone.test(body[0])) {\n                      tone = body[0].replace(reg_tone, \"$2\");\n                    }\n\n                    if (reg_duration.test(body[1])) {\n                      duration = parseInt(body[1].replace(reg_duration, \"$2\"), 10);\n                    }\n                  }\n                }\n\n                new DTMF(this, tone, {\n                  duration: duration\n                }).init_incoming(request);\n              } else {\n                request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n              }\n            }\n          }\n\n          break;\n\n        case SIP.C.REFER:\n          if (this.status === C.STATUS_CONFIRMED) {\n            this.logger.log('REFER received');\n            var hasReferListener = this.listeners('refer').length,\n                notifyBody;\n\n            if (hasReferListener) {\n              request.reply(202, 'Accepted');\n              notifyBody = 'SIP/2.0 100 Trying';\n              this.sendRequest(SIP.C.NOTIFY, {\n                extraHeaders: ['Event: refer', 'Subscription-State: terminated', 'Content-Type: message/sipfrag'],\n                body: notifyBody,\n                receiveResponse: function receiveResponse() {}\n              });\n              this.emit('refer', request);\n            } else {\n              // RFC 3515.2.4.2: 'the UA MAY decline the request.'\n              request.reply(603, 'Declined');\n            }\n          }\n\n          break;\n\n        case SIP.C.NOTIFY:\n          request.reply(200, 'OK');\n          this.emit('notify', request);\n          break;\n      }\n    },\n\n    /**\n     * Reception of Response for in-dialog INVITE\n     * @private\n     */\n    receiveReinviteResponse: function receiveReinviteResponse(response) {\n      var self = this;\n\n      if (this.status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      switch (true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          break;\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this.status = C.STATUS_CONFIRMED;\n          this.sendRequest(SIP.C.ACK, {\n            cseq: response.cseq\n          });\n\n          if (!this.mediaHandler.hasDescription(response)) {\n            this.reinviteFailed();\n            break;\n          } //REVISIT\n\n\n          this.mediaHandler.setDescription(response).then(function onSuccess() {\n            self.reinviteSucceeded();\n          }, function onFailure() {\n            self.reinviteFailed();\n          });\n          break;\n\n        default:\n          this.reinviteFailed();\n      }\n    },\n    acceptAndTerminate: function acceptAndTerminate(response, status_code, reason_phrase) {\n      var extraHeaders = [];\n\n      if (status_code) {\n        extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));\n      } // An error on dialog creation will fire 'failed' event\n\n\n      if (this.dialog || this.createDialog(response, 'UAC')) {\n        this.sendRequest(SIP.C.ACK, {\n          cseq: response.cseq\n        });\n        this.sendRequest(SIP.C.BYE, {\n          extraHeaders: extraHeaders\n        });\n      }\n\n      return this;\n    },\n\n    /**\n     * RFC3261 13.3.1.4\n     * Response retransmissions cannot be accomplished by transaction layer\n     *  since it is destroyed when receiving the first 2xx answer\n     */\n    setInvite2xxTimer: function setInvite2xxTimer(request, description) {\n      var self = this,\n          timeout = SIP.Timers.T1;\n      this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n        if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n          return;\n        }\n\n        self.logger.log('no ACK received, attempting to retransmit OK');\n        var extraHeaders = ['Contact: ' + self.contact];\n        request.reply(200, null, extraHeaders, description);\n        timeout = Math.min(timeout * 2, SIP.Timers.T2);\n        self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n      }, timeout);\n    },\n\n    /**\n     * RFC3261 14.2\n     * If a UAS generates a 2xx response and never receives an ACK,\n     *  it SHOULD generate a BYE to terminate the dialog.\n     */\n    setACKTimer: function setACKTimer() {\n      var self = this;\n      this.timers.ackTimer = SIP.Timers.setTimeout(function () {\n        if (self.status === C.STATUS_WAITING_FOR_ACK) {\n          self.logger.log('no ACK received for an extended period of time, terminating the call');\n          SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n          self.sendRequest(SIP.C.BYE);\n          self.terminated(null, SIP.C.causes.NO_ACK);\n        }\n      }, SIP.Timers.TIMER_H);\n    },\n\n    /*\n     * @private\n     */\n    onReadyToReinvite: function onReadyToReinvite() {\n      var action = this.pending_actions.shift();\n\n      if (!action || !this[action.name]) {\n        return;\n      }\n\n      this[action.name]();\n    },\n    onTransportError: function onTransportError() {\n      if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n        this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n      }\n    },\n    onRequestTimeout: function onRequestTimeout() {\n      if (this.status === C.STATUS_CONFIRMED) {\n        this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n      } else if (this.status !== C.STATUS_TERMINATED) {\n        this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n        this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n      }\n    },\n    onDialogError: function onDialogError(response) {\n      if (this.status === C.STATUS_CONFIRMED) {\n        this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n      } else if (this.status !== C.STATUS_TERMINATED) {\n        this.failed(response, SIP.C.causes.DIALOG_ERROR);\n        this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n      }\n    },\n\n    /**\n     * @private\n     */\n    onhold: function onhold(originator) {\n      this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;\n      this.emit('hold', {\n        originator: originator\n      });\n    },\n\n    /**\n     * @private\n     */\n    onunhold: function onunhold(originator) {\n      this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;\n      this.emit('unhold', {\n        originator: originator\n      });\n    },\n\n    /*\n     * @private\n     */\n    onmute: function onmute(options) {\n      this.emit('muted', {\n        audio: options.audio,\n        video: options.video\n      });\n    },\n\n    /*\n     * @private\n     */\n    onunmute: function onunmute(options) {\n      this.emit('unmuted', {\n        audio: options.audio,\n        video: options.video\n      });\n    },\n    failed: function failed(response, cause) {\n      if (this.status === C.STATUS_TERMINATED) {\n        return this;\n      }\n\n      this.emit('failed', response || null, cause || null);\n      return this;\n    },\n    rejected: function rejected(response, cause) {\n      this.emit('rejected', response || null, cause || null);\n      return this;\n    },\n    canceled: function canceled() {\n      this.emit('cancel');\n      return this;\n    },\n    accepted: function accepted(response, cause) {\n      cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);\n      this.startTime = new Date();\n\n      if (this.replacee) {\n        this.replacee.emit('replaced', this);\n        this.replacee.terminate();\n      }\n\n      if (response) {\n        RFC4028.updateState(this.dialog, response, SIP.Parser.parseMessage, this.ua);\n      }\n\n      this.emit('accepted', response, cause);\n      return this;\n    },\n    terminated: function terminated(message, cause) {\n      if (this.status === C.STATUS_TERMINATED) {\n        return this;\n      }\n\n      this.endTime = new Date();\n      this.close();\n      this.emit('terminated', message || null, cause || null);\n      return this;\n    },\n    connecting: function connecting(request) {\n      this.emit('connecting', {\n        request: request\n      });\n      return this;\n    }\n  };\n\n  Session.desugar = function desugar(options) {\n    if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {\n      options = {\n        media: {\n          constraints: {\n            audio: true,\n            video: options.tagName === 'VIDEO'\n          },\n          render: {\n            remote: options\n          }\n        }\n      };\n    }\n\n    return options || {};\n  };\n\n  Session.C = C;\n  SIP.Session = Session;\n\n  InviteServerContext = function InviteServerContext(ua, request) {\n    var expires,\n        self = this,\n        contentType = request.getHeader('Content-Type'),\n        contentDisp = request.parseHeader('Content-Disposition');\n    SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n    SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]); //Initialize Media Session\n\n    this.mediaHandler = this.mediaHandlerFactory(this, {\n      RTCConstraints: {\n        \"optional\": [{\n          'DtlsSrtpKeyAgreement': 'true'\n        }]\n      }\n    }); // Check body and content type\n\n    if (!contentDisp && !this.mediaHandler.hasDescription(request) || contentDisp && contentDisp.type === 'render') {\n      this.renderbody = request.body;\n      this.rendertype = contentType;\n    } else if (!this.mediaHandler.hasDescription(request) && contentDisp && contentDisp.type === 'session') {\n      request.reply(415); //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it\n\n      return;\n    } // TODO test\n    // http://tools.ietf.org/html/rfc4028#section-9\n\n\n    if (RFC4028.hasSmallMinSE(request)) {\n      request.reply(422, null, ['Min-SE: ' + RFC4028.localMinSE]);\n      return;\n    }\n\n    this.status = C.STATUS_INVITE_RECEIVED;\n    this.from_tag = request.from_tag;\n    this.id = request.call_id + this.from_tag;\n    this.request = request;\n    this.contact = this.ua.contact.toString();\n\n    this.receiveNonInviteResponse = function () {}; // intentional no-op\n\n\n    this.logger = ua.getLogger('sip.inviteservercontext', this.id); //Save the session into the ua sessions collection.\n\n    this.ua.sessions[this.id] = this; //Get the Expires header value if exists\n\n    if (request.hasHeader('expires')) {\n      expires = request.getHeader('expires') * 1000;\n    } //Set 100rel if necessary\n\n\n    function set100rel(h, c) {\n      if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n        self.rel100 = c;\n      }\n    }\n\n    set100rel('require', SIP.C.supported.REQUIRED);\n    set100rel('supported', SIP.C.supported.SUPPORTED);\n    /* Set the to_tag before\n     * replying a response code that will create a dialog.\n     */\n\n    request.to_tag = SIP.Utils.newTag(); // An error on dialog creation will fire 'failed' event\n\n    if (!this.createDialog(request, 'UAS', true)) {\n      request.reply(500, 'Missing Contact header field');\n      return;\n    }\n\n    if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n      this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n      this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n    }\n\n    function fireNewSession() {\n      var options = {\n        extraHeaders: ['Contact: ' + self.contact]\n      };\n\n      if (self.rel100 !== SIP.C.supported.REQUIRED) {\n        self.progress(options);\n      }\n\n      self.status = C.STATUS_WAITING_FOR_ANSWER; // Set userNoAnswerTimer\n\n      self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function () {\n        request.reply(408);\n        self.failed(request, SIP.C.causes.NO_ANSWER);\n        self.terminated(request, SIP.C.causes.NO_ANSWER);\n      }, self.ua.configuration.noAnswerTimeout);\n      /* Set expiresTimer\n       * RFC3261 13.3.1\n       */\n\n      if (expires) {\n        self.timers.expiresTimer = SIP.Timers.setTimeout(function () {\n          if (self.status === C.STATUS_WAITING_FOR_ANSWER) {\n            request.reply(487);\n            self.failed(request, SIP.C.causes.EXPIRES);\n            self.terminated(request, SIP.C.causes.EXPIRES);\n          }\n        }, expires);\n      }\n\n      self.emit('invite', request);\n    }\n\n    if (!this.mediaHandler.hasDescription(request) || this.renderbody) {\n      SIP.Timers.setTimeout(fireNewSession, 0);\n    } else {\n      this.hasOffer = true;\n      this.mediaHandler.setDescription(request).then(fireNewSession, function onFailure(e) {\n        self.logger.warn('invalid description');\n        self.logger.warn(e);\n        request.reply(488);\n      });\n    }\n  };\n\n  InviteServerContext.prototype = {\n    reject: function reject(options) {\n      // Check Session Status\n      if (this.status === C.STATUS_TERMINATED) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      }\n\n      this.logger.log('rejecting RTCSession');\n      SIP.ServerContext.prototype.reject.call(this, options);\n      return this.terminated();\n    },\n    terminate: function terminate(options) {\n      options = options || {};\n      var extraHeaders = (options.extraHeaders || []).slice(),\n          body = options.body,\n          dialog,\n          self = this;\n\n      if (this.status === C.STATUS_WAITING_FOR_ACK && this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n        dialog = this.dialog;\n\n        this.receiveRequest = function (request) {\n          if (request.method === SIP.C.ACK) {\n            this.sendRequest(SIP.C.BYE, {\n              extraHeaders: extraHeaders,\n              body: body\n            });\n            dialog.terminate();\n          }\n        };\n\n        this.request.server_transaction.on('stateChanged', function () {\n          if (this.state === SIP.Transactions.C.STATUS_TERMINATED && this.dialog) {\n            this.request = new SIP.OutgoingRequest(SIP.C.BYE, this.dialog.remote_target, this.ua, {\n              'cseq': this.dialog.local_seqnum += 1,\n              'call_id': this.dialog.id.call_id,\n              'from_uri': this.dialog.local_uri,\n              'from_tag': this.dialog.id.local_tag,\n              'to_uri': this.dialog.remote_uri,\n              'to_tag': this.dialog.id.remote_tag,\n              'route_set': this.dialog.route_set\n            }, extraHeaders, body);\n            new SIP.RequestSender({\n              request: this.request,\n              onRequestTimeout: function onRequestTimeout() {\n                self.onRequestTimeout();\n              },\n              onTransportError: function onTransportError() {\n                self.onTransportError();\n              },\n              receiveResponse: function receiveResponse() {\n                return;\n              }\n            }, this.ua).send();\n            dialog.terminate();\n          }\n        });\n        this.emit('bye', this.request);\n        this.terminated(); // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n\n        this.dialog = dialog; // Restore the dialog into 'ua' so the ACK can reach 'this' session\n\n        this.ua.dialogs[dialog.id.toString()] = dialog;\n      } else if (this.status === C.STATUS_CONFIRMED) {\n        this.bye(options);\n      } else {\n        this.reject(options);\n      }\n\n      return this;\n    },\n\n    /*\n     * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n     */\n    progress: function progress(options) {\n      options = options || {};\n      var statusCode = options.statusCode || 180,\n          reasonPhrase = options.reasonPhrase,\n          extraHeaders = (options.extraHeaders || []).slice(),\n          iceServers,\n          stunServers = options.stunServers || null,\n          turnServers = options.turnServers || null,\n          body = options.body,\n          response;\n\n      if (statusCode < 100 || statusCode > 199) {\n        throw new TypeError('Invalid statusCode: ' + statusCode);\n      }\n\n      if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n        return this;\n      }\n\n      if (stunServers || turnServers) {\n        if (stunServers) {\n          iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\n          if (!iceServers) {\n            throw new TypeError('Invalid stunServers: ' + stunServers);\n          } else {\n            this.stunServers = iceServers;\n          }\n        }\n\n        if (turnServers) {\n          iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\n          if (!iceServers) {\n            throw new TypeError('Invalid turnServers: ' + turnServers);\n          } else {\n            this.turnServers = iceServers;\n          }\n        }\n\n        this.mediaHandler.updateIceServers({\n          stunServers: this.stunServers,\n          turnServers: this.turnServers\n        });\n      }\n\n      function do100rel() {\n        /* jshint validthis: true */\n        statusCode = options.statusCode || 183; // Set status and add extra headers\n\n        this.status = C.STATUS_WAITING_FOR_PRACK;\n        extraHeaders.push('Contact: ' + this.contact);\n        extraHeaders.push('Require: 100rel');\n        extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000)); // Save media hint for later (referred sessions)\n\n        this.mediaHint = options.media; // Get the session description to add to preaccept with\n\n        this.mediaHandler.getDescription(options.media).then(function onSuccess(description) {\n          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n            return;\n          }\n\n          this.early_sdp = description.body;\n          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true; // Retransmit until we get a response or we time out (see prackTimer below)\n\n          var timeout = SIP.Timers.T1;\n          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n            this.request.reply(statusCode, null, extraHeaders, description);\n            timeout *= 2;\n            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n          }.bind(this), timeout); // Timeout and reject INVITE if no response\n\n          this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n              return;\n            }\n\n            this.logger.log('no PRACK received, rejecting the call');\n            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n            this.request.reply(504);\n            this.terminated(null, SIP.C.causes.NO_PRACK);\n          }.bind(this), SIP.Timers.T1 * 64); // Send the initial response\n\n          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, description);\n          this.emit('progress', response, reasonPhrase);\n        }.bind(this), function onFailure() {\n          this.request.reply(480);\n          this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n        }.bind(this));\n      } // end do100rel\n\n\n      function normalReply() {\n        /* jshint validthis:true */\n        response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n        this.emit('progress', response, reasonPhrase);\n      }\n\n      if (options.statusCode !== 100 && (this.rel100 === SIP.C.supported.REQUIRED || this.rel100 === SIP.C.supported.SUPPORTED && options.rel100 || this.rel100 === SIP.C.supported.SUPPORTED && this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)) {\n        do100rel.apply(this);\n      } else {\n        normalReply.apply(this);\n      }\n\n      return this;\n    },\n\n    /*\n     * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n     */\n    accept: function accept(options) {\n      options = Object.create(Session.desugar(options));\n      SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n      this.mediaHint = options.media;\n      this.onInfo = options.onInfo; // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21\n\n      var //idx, length, hasAudio, hasVideo,\n      self = this,\n          request = this.request,\n          extraHeaders = (options.extraHeaders || []).slice(),\n          //mediaStream = options.mediaStream || null,\n      iceServers,\n          stunServers = options.stunServers || null,\n          turnServers = options.turnServers || null,\n          descriptionCreationSucceeded = function descriptionCreationSucceeded(description) {\n        var response,\n            // run for reply success callback\n        replySucceeded = function replySucceeded() {\n          self.status = C.STATUS_WAITING_FOR_ACK;\n          self.setInvite2xxTimer(request, description);\n          self.setACKTimer();\n        },\n            // run for reply failure callback\n        replyFailed = function replyFailed() {\n          self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n          self.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n        }; // Chrome might call onaddstream before accept() is called, which means\n        // mediaHandler.render() was called without a renderHint, so we need to\n        // re-render now that mediaHint.render has been set.\n        //\n        // Chrome seems to be in the right regarding this, see\n        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream\n\n\n        self.mediaHandler.render();\n        extraHeaders.push('Contact: ' + self.contact);\n        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString()); // TODO test\n        // http://tools.ietf.org/html/rfc4028#section-9\n\n        var supportedOptions = request.parseHeader('Supported') || [];\n        var sessionExpires = request.parseHeader('Session-Expires') || {};\n        var interval = sessionExpires.deltaSeconds;\n\n        if (interval) {\n          var refresher = sessionExpires.refresher || 'uas';\n          extraHeaders.push('Session-Expires: ' + interval + ';' + refresher);\n\n          if (refresher === 'uac' || supportedOptions.indexOf('timer') >= 0) {\n            extraHeaders.push('Require: timer');\n          }\n        }\n\n        if (!self.hasOffer) {\n          self.hasOffer = true;\n        } else {\n          self.hasAnswer = true;\n        }\n\n        response = request.reply(200, null, extraHeaders, description, replySucceeded, replyFailed);\n\n        if (self.status !== C.STATUS_TERMINATED) {\n          // Didn't fail\n          self.accepted(response, SIP.Utils.getReasonPhrase(200));\n        }\n      },\n          descriptionCreationFailed = function descriptionCreationFailed() {\n        if (self.status === C.STATUS_TERMINATED) {\n          return;\n        } // TODO - fail out on error\n\n\n        self.request.reply(480); //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n\n        self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n      }; // Check Session Status\n\n\n      if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n        this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n        return this;\n      } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n        this.status = C.STATUS_ANSWERED;\n      } else if (this.status !== C.STATUS_EARLY_MEDIA) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      }\n\n      if ((stunServers || turnServers) && this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n        if (stunServers) {\n          iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\n          if (!iceServers) {\n            throw new TypeError('Invalid stunServers: ' + stunServers);\n          } else {\n            this.stunServers = iceServers;\n          }\n        }\n\n        if (turnServers) {\n          iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\n          if (!iceServers) {\n            throw new TypeError('Invalid turnServers: ' + turnServers);\n          } else {\n            this.turnServers = iceServers;\n          }\n        }\n\n        this.mediaHandler.updateIceServers({\n          stunServers: this.stunServers,\n          turnServers: this.turnServers\n        });\n      } // An error on dialog creation will fire 'failed' event\n\n\n      if (!this.createDialog(request, 'UAS')) {\n        request.reply(500, 'Missing Contact header field');\n        return this;\n      }\n\n      SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer); // this hold-related code breaks FF accepting new calls - JMF 2014-1-21\n\n      /*\n      length = this.getRemoteStreams().length;\n       for (idx = 0; idx < length; idx++) {\n        if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {\n          hasVideo = true;\n        }\n        if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {\n          hasAudio = true;\n        }\n      }\n       if (!hasAudio && this.mediaConstraints.audio === true) {\n        this.mediaConstraints.audio = false;\n        if (mediaStream) {\n          length = mediaStream.getAudioTracks().length;\n          for (idx = 0; idx < length; idx++) {\n            mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);\n          }\n        }\n      }\n       if (!hasVideo && this.mediaConstraints.video === true) {\n        this.mediaConstraints.video = false;\n        if (mediaStream) {\n          length = mediaStream.getVideoTracks().length;\n          for (idx = 0; idx < length; idx++) {\n            mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);\n          }\n        }\n      }\n      */\n\n      if (this.status === C.STATUS_EARLY_MEDIA) {\n        descriptionCreationSucceeded({});\n      } else {\n        this.mediaHandler.getDescription(self.mediaHint).then(descriptionCreationSucceeded, descriptionCreationFailed);\n      }\n\n      return this;\n    },\n    receiveRequest: function receiveRequest(request) {\n      // ISC RECEIVE REQUEST\n      function confirmSession() {\n        /* jshint validthis:true */\n        var contentType;\n        SIP.Timers.clearTimeout(this.timers.ackTimer);\n        SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n        this.status = C.STATUS_CONFIRMED;\n        this.unmute(); // TODO - this logic assumes Content-Disposition defaults\n\n        contentType = request.getHeader('Content-Type');\n\n        if (!this.mediaHandler.hasDescription(request)) {\n          this.renderbody = request.body;\n          this.rendertype = contentType;\n        }\n\n        this.emit('confirmed', request);\n      }\n\n      switch (request.method) {\n        case SIP.C.CANCEL:\n          /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n           * was in progress and that the UAC MAY continue with the session established by\n           * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n           * established session. So the CANCEL is processed only if the session is not yet\n           * established.\n           */\n\n          /*\n           * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n           *request opening the session.\n           */\n          if (this.status === C.STATUS_WAITING_FOR_ANSWER || this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK || this.status === C.STATUS_EARLY_MEDIA || this.status === C.STATUS_ANSWERED) {\n            this.status = C.STATUS_CANCELED;\n            this.request.reply(487);\n            this.canceled(request);\n            this.rejected(request, SIP.C.causes.CANCELED);\n            this.failed(request, SIP.C.causes.CANCELED);\n            this.terminated(request, SIP.C.causes.CANCELED);\n          }\n\n          break;\n\n        case SIP.C.ACK:\n          if (this.status === C.STATUS_WAITING_FOR_ACK) {\n            if (!this.hasAnswer) {\n              if (this.mediaHandler.hasDescription(request)) {\n                // ACK contains answer to an INVITE w/o SDP negotiation\n                this.hasAnswer = true;\n                this.mediaHandler.setDescription(request).then(confirmSession.bind(this), function onFailure(e) {\n                  this.logger.warn(e);\n                  this.terminate({\n                    statusCode: '488',\n                    reasonPhrase: 'Bad Media Description'\n                  });\n                  this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                  this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                }.bind(this));\n              } else if (this.early_sdp) {\n                confirmSession.apply(this);\n              } else {\n                //TODO: Pass to mediahandler\n                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }\n            } else {\n              confirmSession.apply(this);\n            }\n          }\n\n          break;\n\n        case SIP.C.PRACK:\n          if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n            //localMedia = session.mediaHandler.localMedia;\n            if (!this.hasAnswer) {\n              if (this.mediaHandler.hasDescription(request)) {\n                this.hasAnswer = true;\n                this.mediaHandler.setDescription(request).then(function onSuccess() {\n                  SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n                  SIP.Timers.clearTimeout(this.timers.prackTimer);\n                  request.reply(200);\n\n                  if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n                    this.status = C.STATUS_EARLY_MEDIA;\n                    this.accept();\n                  }\n\n                  this.status = C.STATUS_EARLY_MEDIA; //REVISIT\n\n                  this.mute();\n                }.bind(this), function onFailure(e) {\n                  //TODO: Send to media handler\n                  this.logger.warn(e);\n                  this.terminate({\n                    statusCode: '488',\n                    reasonPhrase: 'Bad Media Description'\n                  });\n                  this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                  this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                }.bind(this));\n              } else {\n                this.terminate({\n                  statusCode: '488',\n                  reasonPhrase: 'Bad Media Description'\n                });\n                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }\n            } else {\n              SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n              SIP.Timers.clearTimeout(this.timers.prackTimer);\n              request.reply(200);\n\n              if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n                this.status = C.STATUS_EARLY_MEDIA;\n                this.accept();\n              }\n\n              this.status = C.STATUS_EARLY_MEDIA; //REVISIT\n\n              this.mute();\n            }\n          } else if (this.status === C.STATUS_EARLY_MEDIA) {\n            request.reply(200);\n          }\n\n          break;\n\n        default:\n          Session.prototype.receiveRequest.apply(this, [request]);\n          break;\n      }\n    },\n    onTransportError: function onTransportError() {\n      if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n        this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n      }\n    },\n    onRequestTimeout: function onRequestTimeout() {\n      if (this.status === C.STATUS_CONFIRMED) {\n        this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n      } else if (this.status !== C.STATUS_TERMINATED) {\n        this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n        this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n      }\n    }\n  };\n  SIP.InviteServerContext = InviteServerContext;\n\n  InviteClientContext = function InviteClientContext(ua, target, options) {\n    options = Object.create(Session.desugar(options));\n    options.params = Object.create(options.params || Object.prototype);\n    var iceServers,\n        extraHeaders = (options.extraHeaders || []).slice(),\n        stunServers = options.stunServers || null,\n        turnServers = options.turnServers || null,\n        mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,\n        isMediaSupported = mediaHandlerFactory.isSupported; // Check WebRTC support\n\n    if (isMediaSupported && !isMediaSupported()) {\n      throw new SIP.Exceptions.NotSupportedError('Media not supported');\n    }\n\n    this.RTCConstraints = options.RTCConstraints || {};\n    this.inviteWithoutSdp = options.inviteWithoutSdp || false; // Set anonymous property\n\n    this.anonymous = options.anonymous || false; // Custom data to be sent either in INVITE or in ACK\n\n    this.renderbody = options.renderbody || null;\n    this.rendertype = options.rendertype || 'text/plain';\n    options.params.from_tag = this.from_tag;\n    /* Do not add ;ob in initial forming dialog requests if the registration over\n     *  the current connection got a GRUU URI.\n     */\n\n    this.contact = ua.contact.toString({\n      anonymous: this.anonymous,\n      outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n    });\n\n    if (this.anonymous) {\n      options.params.from_displayName = 'Anonymous';\n      options.params.from_uri = 'sip:anonymous@anonymous.invalid';\n      extraHeaders.push('P-Preferred-Identity: ' + ua.configuration.uri.toString());\n      extraHeaders.push('Privacy: id');\n    }\n\n    extraHeaders.push('Contact: ' + this.contact);\n    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n\n    if (this.inviteWithoutSdp && this.renderbody) {\n      extraHeaders.push('Content-Type: ' + this.rendertype);\n      extraHeaders.push('Content-Disposition: render;handling=optional');\n    }\n\n    if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n      extraHeaders.push('Require: 100rel');\n    }\n\n    if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {\n      extraHeaders.push('Require: replaces');\n    }\n\n    options.extraHeaders = extraHeaders;\n    SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n    SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]); // Check Session Status\n\n    if (this.status !== C.STATUS_NULL) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    } // Session parameter initialization\n\n\n    this.from_tag = SIP.Utils.newTag(); // OutgoingSession specific parameters\n\n    this.isCanceled = false;\n    this.received_100 = false;\n    this.method = SIP.C.INVITE;\n    this.receiveNonInviteResponse = this.receiveResponse;\n    this.receiveResponse = this.receiveInviteResponse;\n    this.logger = ua.getLogger('sip.inviteclientcontext');\n\n    if (stunServers) {\n      iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n\n      if (!iceServers) {\n        throw new TypeError('Invalid stunServers: ' + stunServers);\n      } else {\n        this.stunServers = iceServers;\n      }\n    }\n\n    if (turnServers) {\n      iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n\n      if (!iceServers) {\n        throw new TypeError('Invalid turnServers: ' + turnServers);\n      } else {\n        this.turnServers = iceServers;\n      }\n    }\n\n    ua.applicants[this] = this;\n    this.id = this.request.call_id + this.from_tag; //Initialize Media Session\n\n    this.mediaHandler = this.mediaHandlerFactory(this, {\n      RTCConstraints: this.RTCConstraints,\n      stunServers: this.stunServers,\n      turnServers: this.turnServers\n    });\n\n    if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n      this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n      this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n    }\n\n    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n    this.mediaHint = options.media;\n    this.onInfo = options.onInfo;\n  };\n\n  InviteClientContext.prototype = {\n    invite: function invite() {\n      var self = this; //Save the session into the ua sessions collection.\n      //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n\n      this.ua.sessions[this.id] = this; //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level\n      // and hand sip.js a stream as the mediaHint\n\n      if (this.inviteWithoutSdp) {\n        //just send an invite with no sdp...\n        this.request.body = self.renderbody;\n        this.status = C.STATUS_INVITE_SENT;\n        this.send();\n      } else {\n        this.mediaHandler.getDescription(self.mediaHint).then(function onSuccess(description) {\n          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n            return;\n          }\n\n          self.hasOffer = true;\n          self.request.body = description;\n          self.status = C.STATUS_INVITE_SENT;\n          self.send();\n        }, function onFailure() {\n          if (self.status === C.STATUS_TERMINATED) {\n            return;\n          } // TODO...fail out\n          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n\n\n          self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n        });\n      }\n\n      return this;\n    },\n    receiveInviteResponse: function receiveInviteResponse(response) {\n      var cause,\n          //localMedia,\n      session = this,\n          id = response.call_id + response.from_tag + response.to_tag,\n          extraHeaders = [],\n          options = {};\n\n      if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n        return;\n      }\n\n      if (this.dialog && response.status_code >= 200 && response.status_code <= 299) {\n        if (id !== this.dialog.id.toString()) {\n          if (!this.createDialog(response, 'UAC', true)) {\n            return;\n          }\n\n          this.earlyDialogs[id].sendRequest(this, SIP.C.ACK, {\n            body: SIP.Utils.generateFakeSDP(response.body)\n          });\n          this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n          /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n           * leg (due to peerConnection limitations) has been answered first. If your forking\n           * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n           */\n\n          if (this.status !== C.STATUS_CONFIRMED) {\n            this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n            this.terminated(response, SIP.C.causes.WEBRTC_ERROR);\n          }\n\n          return;\n        } else if (this.status === C.STATUS_CONFIRMED) {\n          this.sendRequest(SIP.C.ACK, {\n            cseq: response.cseq\n          });\n          return;\n        } else if (!this.hasAnswer) {\n          // invite w/o sdp is waiting for callback\n          //an invite with sdp must go on, and hasAnswer is true\n          return;\n        }\n      }\n\n      if (this.dialog && response.status_code < 200) {\n        /*\n          Early media has been set up with at least one other different branch,\n          but a final 2xx response hasn't been received\n        */\n        if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 || this.dialog.pracked[this.dialog.pracked.length - 1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0) {\n          return;\n        }\n\n        if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n          return;\n        }\n\n        if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 || this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length - 1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0) {\n          return;\n        }\n\n        extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n        this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n        this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n          extraHeaders: extraHeaders,\n          body: SIP.Utils.generateFakeSDP(response.body)\n        });\n        return;\n      } // Proceed to cancellation if the user requested.\n\n\n      if (this.isCanceled) {\n        if (response.status_code >= 100 && response.status_code < 200) {\n          this.request.cancel(this.cancelReason, extraHeaders);\n          this.canceled(null);\n        } else if (response.status_code >= 200 && response.status_code < 299) {\n          this.acceptAndTerminate(response);\n          this.emit('bye', this.request);\n        } else if (response.status_code >= 300) {\n          cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;\n          this.rejected(response, cause);\n          this.failed(response, cause);\n          this.terminated(response, cause);\n        }\n\n        return;\n      }\n\n      switch (true) {\n        case /^100$/.test(response.status_code):\n          this.received_100 = true;\n          this.emit('progress', response);\n          break;\n\n        case /^1[0-9]{2}$/.test(response.status_code):\n          // Do nothing with 1xx responses without To tag.\n          if (!response.to_tag) {\n            this.logger.warn('1xx response received without to tag');\n            break;\n          } // Create Early Dialog if 1XX comes with contact\n\n\n          if (response.hasHeader('contact')) {\n            // An error on dialog creation will fire 'failed' event\n            if (!this.createDialog(response, 'UAC', true)) {\n              break;\n            }\n          }\n\n          this.status = C.STATUS_1XX_RECEIVED;\n\n          if (response.hasHeader('require') && response.getHeader('require').indexOf('100rel') !== -1) {\n            // Do nothing if this.dialog is already confirmed\n            if (this.dialog || !this.earlyDialogs[id]) {\n              break;\n            }\n\n            if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 || this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length - 1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0) {\n              return;\n            }\n\n            if (!this.mediaHandler.hasDescription(response)) {\n              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n              this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n              this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n                extraHeaders: extraHeaders\n              });\n              this.emit('progress', response);\n            } else if (this.hasOffer) {\n              if (!this.createDialog(response, 'UAC')) {\n                break;\n              }\n\n              this.hasAnswer = true;\n              this.dialog.pracked.push(response.getHeader('rseq'));\n              this.mediaHandler.setDescription(response).then(function onSuccess() {\n                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                session.sendRequest(SIP.C.PRACK, {\n                  extraHeaders: extraHeaders,\n                  receiveResponse: function receiveResponse() {}\n                });\n                session.status = C.STATUS_EARLY_MEDIA;\n                session.mute();\n                session.emit('progress', response);\n                /*\n                if (session.status === C.STATUS_EARLY_MEDIA) {\n                  localMedia = session.mediaHandler.localMedia;\n                  if (localMedia.getAudioTracks().length > 0) {\n                    localMedia.getAudioTracks()[0].enabled = false;\n                  }\n                  if (localMedia.getVideoTracks().length > 0) {\n                    localMedia.getVideoTracks()[0].enabled = false;\n                  }\n                }*/\n              }, function onFailure(e) {\n                session.logger.warn(e);\n                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              });\n            } else {\n              var earlyDialog = this.earlyDialogs[id];\n              var earlyMedia = earlyDialog.mediaHandler;\n              earlyDialog.pracked.push(response.getHeader('rseq'));\n              earlyMedia.setDescription(response).then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint)).then(function onSuccess(description) {\n                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                earlyDialog.sendRequest(session, SIP.C.PRACK, {\n                  extraHeaders: extraHeaders,\n                  body: description\n                });\n                session.status = C.STATUS_EARLY_MEDIA;\n                session.emit('progress', response);\n              }).catch(function onFailure(e) {\n                if (e instanceof SIP.Exceptions.GetDescriptionError) {\n                  earlyDialog.pracked.push(response.getHeader('rseq'));\n\n                  if (session.status === C.STATUS_TERMINATED) {\n                    return;\n                  } // TODO - fail out on error\n                  // session.failed(gum error);\n\n\n                  session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                  session.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n                } else {\n                  earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1); // Could not set remote description\n\n                  session.logger.warn('invalid description');\n                  session.logger.warn(e);\n                }\n              });\n            }\n          } else {\n            this.emit('progress', response);\n          }\n\n          break;\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          var cseq = this.request.cseq + ' ' + this.request.method;\n\n          if (cseq !== response.getHeader('cseq')) {\n            break;\n          }\n\n          if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n            this.status = C.STATUS_CONFIRMED;\n            this.unmute();\n            /*localMedia = this.mediaHandler.localMedia;\n            if (localMedia.getAudioTracks().length > 0) {\n              localMedia.getAudioTracks()[0].enabled = true;\n            }\n            if (localMedia.getVideoTracks().length > 0) {\n              localMedia.getVideoTracks()[0].enabled = true;\n            }*/\n\n            options = {};\n\n            if (this.renderbody) {\n              extraHeaders.push('Content-Type: ' + this.rendertype);\n              options.extraHeaders = extraHeaders;\n              options.body = this.renderbody;\n            }\n\n            options.cseq = response.cseq;\n            this.sendRequest(SIP.C.ACK, options);\n            this.accepted(response);\n            break;\n          } // Do nothing if this.dialog is already confirmed\n\n\n          if (this.dialog) {\n            break;\n          } // This is an invite without sdp\n\n\n          if (!this.hasOffer) {\n            if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {\n              //REVISIT\n              this.hasOffer = true;\n              this.hasAnswer = true;\n              this.mediaHandler = this.earlyDialogs[id].mediaHandler;\n\n              if (!this.createDialog(response, 'UAC')) {\n                break;\n              }\n\n              this.status = C.STATUS_CONFIRMED;\n              this.sendRequest(SIP.C.ACK, {\n                cseq: response.cseq\n              });\n              this.unmute();\n              /*\n              localMedia = session.mediaHandler.localMedia;\n              if (localMedia.getAudioTracks().length > 0) {\n                localMedia.getAudioTracks()[0].enabled = true;\n              }\n              if (localMedia.getVideoTracks().length > 0) {\n                localMedia.getVideoTracks()[0].enabled = true;\n              }*/\n\n              this.accepted(response);\n            } else {\n              if (!this.mediaHandler.hasDescription(response)) {\n                this.acceptAndTerminate(response, 400, 'Missing session description');\n                this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                break;\n              }\n\n              if (!this.createDialog(response, 'UAC')) {\n                break;\n              }\n\n              this.hasOffer = true;\n              this.mediaHandler.setDescription(response).then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint)).then(function onSuccess(description) {\n                //var localMedia;\n                if (session.isCanceled || session.status === C.STATUS_TERMINATED) {\n                  return;\n                }\n\n                session.status = C.STATUS_CONFIRMED;\n                session.hasAnswer = true;\n                session.unmute();\n                /*localMedia = session.mediaHandler.localMedia;\n                if (localMedia.getAudioTracks().length > 0) {\n                  localMedia.getAudioTracks()[0].enabled = true;\n                }\n                if (localMedia.getVideoTracks().length > 0) {\n                  localMedia.getVideoTracks()[0].enabled = true;\n                }*/\n\n                session.sendRequest(SIP.C.ACK, {\n                  body: description,\n                  cseq: response.cseq\n                });\n                session.accepted(response);\n              }).catch(function onFailure(e) {\n                if (e instanceof SIP.Exceptions.GetDescriptionError) {\n                  // TODO do something here\n                  session.logger.warn(\"there was a problem\");\n                } else {\n                  session.logger.warn('invalid description');\n                  session.logger.warn(e);\n                  response.reply(488);\n                }\n              });\n            }\n          } else if (this.hasAnswer) {\n            if (this.renderbody) {\n              extraHeaders.push('Content-Type: ' + session.rendertype);\n              options.extraHeaders = extraHeaders;\n              options.body = this.renderbody;\n            }\n\n            this.sendRequest(SIP.C.ACK, options);\n          } else {\n            if (!this.mediaHandler.hasDescription(response)) {\n              this.acceptAndTerminate(response, 400, 'Missing session description');\n              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              break;\n            }\n\n            if (!this.createDialog(response, 'UAC')) {\n              break;\n            }\n\n            this.hasAnswer = true;\n            this.mediaHandler.setDescription(response).then(function onSuccess() {\n              var options = {}; //,localMedia;\n\n              session.status = C.STATUS_CONFIRMED;\n              session.unmute();\n              /*localMedia = session.mediaHandler.localMedia;\n              if (localMedia.getAudioTracks().length > 0) {\n                localMedia.getAudioTracks()[0].enabled = true;\n              }\n              if (localMedia.getVideoTracks().length > 0) {\n                localMedia.getVideoTracks()[0].enabled = true;\n              }*/\n\n              if (session.renderbody) {\n                extraHeaders.push('Content-Type: ' + session.rendertype);\n                options.extraHeaders = extraHeaders;\n                options.body = session.renderbody;\n              }\n\n              options.cseq = response.cseq;\n              session.sendRequest(SIP.C.ACK, options);\n              session.accepted(response);\n            }, function onFailure(e) {\n              session.logger.warn(e);\n              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n            });\n          }\n\n          break;\n\n        default:\n          cause = SIP.Utils.sipErrorCause(response.status_code);\n          this.rejected(response, cause);\n          this.failed(response, cause);\n          this.terminated(response, cause);\n      }\n    },\n    cancel: function cancel(options) {\n      options = options || {};\n      options.extraHeaders = (options.extraHeaders || []).slice(); // Check Session Status\n\n      if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      }\n\n      this.logger.log('canceling RTCSession');\n      var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase); // Check Session Status\n\n      if (this.status === C.STATUS_NULL || this.status === C.STATUS_INVITE_SENT && !this.received_100) {\n        this.isCanceled = true;\n        this.cancelReason = cancel_reason;\n      } else if (this.status === C.STATUS_INVITE_SENT || this.status === C.STATUS_1XX_RECEIVED || this.status === C.STATUS_EARLY_MEDIA) {\n        this.request.cancel(cancel_reason, options.extraHeaders);\n      }\n\n      return this.canceled();\n    },\n    terminate: function terminate(options) {\n      if (this.status === C.STATUS_TERMINATED) {\n        return this;\n      }\n\n      if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n        this.bye(options);\n      } else {\n        this.cancel(options);\n      }\n\n      return this;\n    },\n    receiveRequest: function receiveRequest(request) {\n      // ICC RECEIVE REQUEST\n      // Reject CANCELs\n      if (request.method === SIP.C.CANCEL) {// TODO; make this a switch when it gets added\n      }\n\n      if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n        SIP.Timers.clearTimeout(this.timers.ackTimer);\n        SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n        this.status = C.STATUS_CONFIRMED;\n        this.unmute();\n        this.accepted();\n      }\n\n      return Session.prototype.receiveRequest.apply(this, [request]);\n    },\n    onTransportError: function onTransportError() {\n      if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n        this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n      }\n    },\n    onRequestTimeout: function onRequestTimeout() {\n      if (this.status === C.STATUS_CONFIRMED) {\n        this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n      } else if (this.status !== C.STATUS_TERMINATED) {\n        this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n        this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n      }\n    }\n  };\n  SIP.InviteClientContext = InviteClientContext;\n};","map":null,"metadata":{},"sourceType":"script"}