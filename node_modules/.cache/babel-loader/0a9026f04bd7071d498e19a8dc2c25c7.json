{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar RemoteAudioTrack = require('./media/track/remoteaudiotrack');\n\nvar RemoteAudioTrackPublication = require('./media/track/remoteaudiotrackpublication');\n\nvar RemoteDataTrack = require('./media/track/remotedatatrack');\n\nvar RemoteDataTrackPublication = require('./media/track/remotedatatrackpublication');\n\nvar RemoteVideoTrack = require('./media/track/remotevideotrack');\n\nvar RemoteVideoTrackPublication = require('./media/track/remotevideotrackpublication');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('./util');\n\nvar nInstances = 0;\n/**\n * {@link NetworkQualityLevel} is a value from 0â€“5, inclusive, representing the\n * quality of a network connection.\n * @typedef {number} NetworkQualityLevel\n */\n\n/**\n * @extends EventEmitter\n * @property {Map<Track.ID, AudioTrack>} audioTracks -\n *    The {@link Participant}'s {@link AudioTrack}s\n * @property {Map<Track.SID, AudioTrackPublication>} audioTrackPublications -\n *    The {@link Participant}'s {@link AudioTrackPublication}s\n * @property {Map<Track.ID, DataTrack>} dataTracks -\n *    The {@link Participant}'s {@link DataTrack}s\n * @property {Map<Track.SID, DataTrackPublication>} dataTrackPublications -\n *    The {@link Participant}'s {@link DataTrackPublication}s.\n * @property {Participant.Identity} identity - The identity of the {@link Participant}\n * @property {Participant.SID} sid - The {@link Participant}'s SID\n * @property {string} state - \"connected\", \"disconnected\" or \"failed\"\n * @property {Map<Track.ID, Track>} tracks -\n *    The {@link Participant}'s {@link Track}s\n * @property {Map<Track.SID, TrackPublication>} trackPublications -\n *    The {@link Participant}'s {@link TrackPublication}s\n * @property {Map<Track.ID, VideoTrack>} videoTracks -\n *    The {@link Participant}'s {@link VideoTrack}s\n * @property {Map<Track.SID, VideoTrackPublication>} videoTrackPublications -\n *    The {@link Participant}'s {@link VideoTrackPublication}s\n * @emits Participant#disconnected\n * @emits Particiapnt#networkQualityLevelChanged\n * @emits Participant#trackAdded\n * @emits Participant#trackDimensionsChanged\n * @emits Participant#trackDisabled\n * @emits Participant#trackEnabled\n * @emits Participant#trackRemoved\n * @emits Participant#trackStarted\n */\n\nvar Participant = function (_EventEmitter) {\n  _inherits(Participant, _EventEmitter);\n  /**\n   * Construct a {@link Participant}.\n   * @param {ParticipantSignaling} signaling\n   * @param {object} [options]\n   */\n\n\n  function Participant(signaling, options) {\n    _classCallCheck(this, Participant);\n\n    var _this = _possibleConstructorReturn(this, (Participant.__proto__ || Object.getPrototypeOf(Participant)).call(this));\n\n    options = Object.assign({\n      RemoteAudioTrack: RemoteAudioTrack,\n      RemoteAudioTrackPublication: RemoteAudioTrackPublication,\n      RemoteDataTrack: RemoteDataTrack,\n      RemoteDataTrackPublication: RemoteDataTrackPublication,\n      RemoteVideoTrack: RemoteVideoTrack,\n      RemoteVideoTrackPublication: RemoteVideoTrackPublication,\n      tracks: []\n    }, options);\n    var indexed = indexTracksById(options.tracks);\n    var log = options.log.createLog('default', _this);\n    var audioTracks = new Map(indexed.audioTracks);\n    var dataTracks = new Map(indexed.dataTracks);\n    var tracks = new Map(indexed.tracks);\n    var videoTracks = new Map(indexed.videoTracks);\n    Object.defineProperties(_this, {\n      _RemoteAudioTrack: {\n        value: options.RemoteAudioTrack\n      },\n      _RemoteAudioTrackPublication: {\n        value: options.RemoteAudioTrackPublication\n      },\n      _RemoteDataTrack: {\n        value: options.RemoteDataTrack\n      },\n      _RemoteDataTrackPublication: {\n        value: options.RemoteDataTrackPublication\n      },\n      _RemoteVideoTrack: {\n        value: options.RemoteVideoTrack\n      },\n      _RemoteVideoTrackPublication: {\n        value: options.RemoteVideoTrackPublication\n      },\n      _instanceId: {\n        value: ++nInstances\n      },\n      _log: {\n        value: log\n      },\n      _signaling: {\n        value: signaling\n      },\n      _trackEventReemitters: {\n        value: new Map()\n      },\n      _trackPublicationEventReemitters: {\n        value: new Map()\n      },\n      _trackSignalingUpdatedEventCallbacks: {\n        value: new Map()\n      },\n      audioTracks: {\n        enumerable: true,\n        value: audioTracks\n      },\n      audioTrackPublications: {\n        enumerable: true,\n        value: new Map()\n      },\n      dataTracks: {\n        enumerable: true,\n        value: dataTracks\n      },\n      dataTrackPublications: {\n        enumerable: true,\n        value: new Map()\n      },\n      identity: {\n        enumerable: true,\n        get: function get() {\n          return signaling.identity;\n        }\n      },\n      sid: {\n        enumerable: true,\n        get: function get() {\n          return signaling.sid;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function get() {\n          return signaling.state;\n        }\n      },\n      tracks: {\n        enumerable: true,\n        value: tracks\n      },\n      trackPublications: {\n        enumerable: true,\n        value: new Map()\n      },\n      videoTracks: {\n        enumerable: true,\n        value: videoTracks\n      },\n      videoTrackPublications: {\n        enumerable: true,\n        value: new Map()\n      }\n    });\n\n    _this.tracks.forEach(reemitTrackEvents.bind(null, _this));\n\n    signaling.on('networkQualityLevelChanged', function () {\n      return _this.emit('networkQualityLevelChanged', _this.networkQualityLevel);\n    });\n    reemitSignalingStateChangedEvents(_this, signaling);\n    log.info('Created a new Participant' + (_this.identity ? ': ' + _this.identity : ''));\n    return _this;\n  }\n  /**\n   * Get the {@link RemoteTrack} events to re-emit.\n   * @private\n   * @returns {Array<Array<string>>} events\n   */\n\n\n  _createClass(Participant, [{\n    key: '_getTrackEvents',\n    value: function _getTrackEvents() {\n      return [['dimensionsChanged', 'trackDimensionsChanged'], ['disabled', 'trackDisabled'], ['enabled', 'trackEnabled'], ['message', 'trackMessage'], ['started', 'trackStarted']];\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_getTrackPublicationEvents',\n    value: function _getTrackPublicationEvents() {\n      // NOTE(mmalavalli): 'trackDisabled' and 'trackEnabled' will be\n      // re-emitted from the RemoteTrackPublication instead of RemoteTrack\n      // in twilio-video.js@2.0.0 onwards.\n      return [];\n    }\n    /**\n     * Get the current {@link NetworkQualityLevel}, if any.\n     * @returns {?NetworkQualityLevel} networkQualityLevel - initially null\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[Participant #' + this._instanceId + ': ' + this.sid + ']';\n    }\n    /**\n     * @private\n     * @param {RemoteTrack} track\n     * @returns {?RemoteTrack}\n     */\n\n  }, {\n    key: '_addTrack',\n    value: function _addTrack(track) {\n      var log = this._log;\n\n      if (this.tracks.has(track._id)) {\n        return null;\n      }\n\n      this.tracks.set(track._id, track);\n      var tracksByKind = {\n        audio: this.audioTracks,\n        video: this.videoTracks,\n        data: this.dataTracks\n      }[track.kind];\n      tracksByKind.set(track._id, track);\n      reemitTrackEvents(this, track);\n      log.info('Added a new ' + util.trackClass(track) + ':', track._id);\n      log.debug(util.trackClass(track) + ':', track);\n      this.emit('trackAdded', track);\n      return track;\n    }\n    /**\n     * @private\n     * @param {RemoteTrackPublication} publication\n     * @returns {?RemoteTrackPublication}\n     */\n\n  }, {\n    key: '_addTrackPublication',\n    value: function _addTrackPublication(publication) {\n      var log = this._log;\n\n      if (this.trackPublications.has(publication.trackSid)) {\n        return null;\n      }\n\n      this.trackPublications.set(publication.trackSid, publication);\n      var trackPublicationsByKind = {\n        audio: this.audioTrackPublications,\n        data: this.dataTrackPublications,\n        video: this.videoTrackPublications\n      }[publication.kind];\n      trackPublicationsByKind.set(publication.trackSid, publication);\n      reemitTrackPublicationEvents(this, publication);\n      log.info('Added a new ' + util.trackPublicationClass(publication) + ':', publication.trackSid);\n      log.debug(util.trackPublicationClass(publication) + ':', publication);\n      return publication;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: '_handleTrackSignalingEvents',\n    value: function _handleTrackSignalingEvents() {\n      var log = this._log;\n      var self = this;\n\n      if (this.state === 'disconnected') {\n        return;\n      }\n\n      var RemoteAudioTrack = this._RemoteAudioTrack;\n      var RemoteAudioTrackPublication = this._RemoteAudioTrackPublication;\n      var RemoteVideoTrack = this._RemoteVideoTrack;\n      var RemoteVideoTrackPublication = this._RemoteVideoTrackPublication;\n      var RemoteDataTrack = this._RemoteDataTrack;\n      var RemoteDataTrackPublication = this._RemoteDataTrackPublication;\n      var signaling = this._signaling;\n\n      function trackSignalingAdded(signaling) {\n        var RemoteTrackPublication = {\n          audio: RemoteAudioTrackPublication,\n          data: RemoteDataTrackPublication,\n          video: RemoteVideoTrackPublication\n        }[signaling.kind];\n        var publication = new RemoteTrackPublication(signaling, {\n          log: log\n        });\n\n        self._addTrackPublication(publication);\n\n        var isSubscribed = signaling.isSubscribed;\n\n        if (isSubscribed) {\n          trackSignalingSubscribed(signaling);\n        }\n\n        self._trackSignalingUpdatedEventCallbacks.set(signaling.sid, function () {\n          if (isSubscribed !== signaling.isSubscribed) {\n            isSubscribed = signaling.isSubscribed;\n\n            if (isSubscribed) {\n              trackSignalingSubscribed(signaling);\n              return;\n            }\n\n            trackSignalingUnsubscribed(signaling);\n          }\n        });\n\n        signaling.on('updated', self._trackSignalingUpdatedEventCallbacks.get(signaling.sid));\n      }\n\n      function trackSignalingRemoved(signaling) {\n        if (signaling.isSubscribed) {\n          signaling.setTrackTransceiver(null);\n        }\n\n        var updated = self._trackSignalingUpdatedEventCallbacks.get(signaling.sid);\n\n        if (updated) {\n          signaling.removeListener('updated', updated);\n\n          self._trackSignalingUpdatedEventCallbacks.delete(signaling.id);\n        }\n\n        var publication = self.trackPublications.get(signaling.sid);\n\n        if (publication) {\n          self._removeTrackPublication(publication);\n        }\n      }\n\n      function trackSignalingSubscribed(signaling) {\n        var RemoteTrack = {\n          audio: RemoteAudioTrack,\n          video: RemoteVideoTrack,\n          data: RemoteDataTrack\n        }[signaling.kind];\n        var publication = self.trackPublications.get(signaling.sid);\n        var trackReceiver = signaling.trackTransceiver; // NOTE(mroberts): It should never be the case that the TrackSignaling and\n        // MediaStreamTrack or DataTrackReceiver kinds disagree; however, just in\n        // case, we handle it here.\n\n        if (!RemoteTrack || signaling.kind !== trackReceiver.kind) {\n          return;\n        }\n\n        var track = signaling.kind === 'data' ? new RemoteTrack(trackReceiver, {\n          log: log,\n          name: signaling.name\n        }) : new RemoteTrack(trackReceiver, signaling.isEnabled, {\n          log: log,\n          name: signaling.name\n        });\n\n        self._addTrack(track, publication);\n      }\n\n      function trackSignalingUnsubscribed(signaling) {\n        var track = util.flatMap(self.tracks).find(function (track) {\n          return track.sid === signaling.sid;\n        });\n        var publication = self.trackPublications.get(signaling.sid);\n\n        if (track) {\n          self._removeTrack(track, publication);\n        }\n      }\n\n      signaling.on('trackAdded', trackSignalingAdded);\n      signaling.on('trackRemoved', trackSignalingRemoved);\n      signaling.tracks.forEach(trackSignalingAdded);\n      signaling.on('stateChanged', function stateChanged(state) {\n        if (state === 'disconnected') {\n          log.debug('Removing event listeners');\n          signaling.removeListener('stateChanged', stateChanged);\n          signaling.removeListener('trackAdded', trackSignalingAdded);\n          signaling.removeListener('trackRemoved', trackSignalingRemoved);\n        }\n      });\n    }\n    /**\n     * @private\n     * @param {RemoteTrack} track\n     */\n\n  }, {\n    key: '_deleteTrack',\n    value: function _deleteTrack(track) {\n      this.tracks.delete(track._id);\n      var tracksByKind = {\n        audio: this.audioTracks,\n        video: this.videoTracks,\n        data: this.dataTracks\n      }[track.kind];\n      tracksByKind.delete(track._id);\n      var reemitters = this._trackEventReemitters.get(track._id) || new Map();\n      reemitters.forEach(function (reemitter, event) {\n        track.removeListener(event, reemitter);\n      });\n      var log = this._log;\n      log.info('Removed a ' + util.trackClass(track) + ':', track._id);\n      log.debug(util.trackClass(track) + ':', track);\n    }\n    /**\n     * @private\n     * @param {RemoteTrack} track\n     * @returns {?RemoteTrack}\n     */\n\n  }, {\n    key: '_removeTrack',\n    value: function _removeTrack(track) {\n      if (!this.tracks.has(track._id)) {\n        return null;\n      }\n\n      track = this.tracks.get(track._id);\n\n      this._deleteTrack(track);\n\n      this.emit('trackRemoved', track);\n      return track;\n    }\n    /**\n     * @private\n     * @param {RemoteTrackPublication} publication\n     * @returns {?RemoteTrackPublication}\n     */\n\n  }, {\n    key: '_removeTrackPublication',\n    value: function _removeTrackPublication(publication) {\n      publication = this.trackPublications.get(publication.trackSid);\n\n      if (!publication) {\n        return null;\n      }\n\n      this.trackPublications.delete(publication.trackSid);\n      var trackPublicationsByKind = {\n        audio: this.audioTrackPublications,\n        data: this.dataTrackPublications,\n        video: this.videoTrackPublications\n      }[publication.kind];\n      trackPublicationsByKind.delete(publication.trackSid);\n      var reemitters = this._trackPublicationEventReemitters.get(publication.trackSid) || new Map();\n      reemitters.forEach(function (reemitter, event) {\n        publication.removeListener(event, reemitter);\n      });\n      var log = this._log;\n      log.info('Removed a ' + util.trackPublicationClass(publication) + ':', publication.trackSid);\n      log.debug(util.trackPublicationClass(publication) + ':', publication);\n      return publication;\n    }\n  }, {\n    key: 'networkQualityLevel',\n    get: function get() {\n      return this._signaling.networkQualityLevel;\n    }\n    /**\n     * Get the current {@link NetworkQualityLevels}, if any.\n     * @private\n     * @deprecated - the decomposed levels are only used for debugging and will be\n     *   removed as soon as we are confident in our implementation\n     * @returns {?NetworkQualityLevels} networkQualityLevels - initially null\n     */\n\n  }, {\n    key: '_networkQualityLevels',\n    get: function get() {\n      return this._signaling.networkQualityLevels;\n    }\n  }]);\n\n  return Participant;\n}(EventEmitter);\n/**\n * A {@link Participant.SID} is a 34-character string starting with \"PA\"\n * that uniquely identifies a {@link Participant}.\n * @type string\n * @typedef Participant.SID\n */\n\n/**\n * A {@link Participant.Identity} is a string that identifies a\n * {@link Participant}. You can think of it like a name.\n * @typedef {string} Participant.Identity\n */\n\n/**\n * The {@link Participant} has disconnected.\n * @param {Participant} participant - The {@link Participant} that disconnected.\n * @event Participant#disconnected\n */\n\n/**\n * The {@link Participant}'s {@link NetworkQualityLevel} changed.\n * @param {NetworkQualityLevel} networkQualityLevel - The new\n *   {@link NetworkQualityLevel}\n * @event Participant#networkQualityLevelChanged\n */\n\n/**\n * A {@link Track} was added by the {@link Participant}.\n * @param {Track} track - The {@link Track} that was added\n * @event Participant#trackAdded\n * @deprecated\n */\n\n/**\n * One of the {@link Participant}'s {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event Participant#trackDimensionsChanged\n */\n\n/**\n * A {@link Track} was disabled by the {@link Participant}.\n * @param {Track} track - The {@link Track} that was disabled.\n * @event Participant#trackDisabled\n */\n\n/**\n * A {@link Track} was enabled by the {@link Participant}.\n * @param {Track} track - The {@link Track} that was enabled\n * @event Participant#trackEnabled\n */\n\n/**\n * A {@link Track} was removed by the {@link Participant}.\n * @param {Track} track - The {@link Track} that was removed\n * @event Participant#trackRemoved\n * @deprecated\n */\n\n/**\n * One of the {@link Participant}'s {@link Track}s started.\n * @param {Track} track - The {@link Track} that started\n * @event Participant#trackStarted\n */\n\n/**\n * Indexed {@link Track}s by {@link Track.ID}.\n * @typedef {object} IndexedTracks\n * @property {Array<{0: Track.ID, 1: AudioTrack}>} audioTracks - Indexed\n *   {@link AudioTrack}s\n * @property {Array<{0: Track.ID, 1: DataTrack}>} dataTracks - Indexed\n *   {@link DataTrack}s\n * @property {Array<{0: Track.ID, 1: Track}>} tracks - Indexed {@link Track}s\n * @property {Array<{0: Track.ID, 1: VideoTrack}>} videoTracks - Indexed\n *   {@link VideoTrack}s\n * @private\n */\n\n/**\n * Index tracks by {@link Track.ID}.\n * @param {Array<Track>} tracks\n * @returns {IndexedTracks}\n * @private\n */\n\n\nfunction indexTracksById(tracks) {\n  var indexedTracks = tracks.map(function (track) {\n    return [track._id, track];\n  });\n  var indexedAudioTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'audio';\n  });\n  var indexedVideoTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'video';\n  });\n  var indexedDataTracks = indexedTracks.filter(function (keyValue) {\n    return keyValue[1].kind === 'data';\n  });\n  return {\n    audioTracks: indexedAudioTracks,\n    dataTracks: indexedDataTracks,\n    tracks: indexedTracks,\n    videoTracks: indexedVideoTracks\n  };\n}\n/**\n * Re-emit {@link ParticipantSignaling} 'stateChanged' events.\n * @param {Participant} participant\n * @param {ParticipantSignaling} signaling\n * @private\n */\n\n\nfunction reemitSignalingStateChangedEvents(participant, signaling) {\n  var log = participant._log;\n\n  if (participant.state === 'disconnected') {\n    return;\n  } // Reemit state transition events from the ParticipantSignaling.\n\n\n  signaling.on('stateChanged', function stateChanged(state) {\n    log.debug('Transitioned to state:', state);\n    participant.emit(state, participant);\n\n    if (state === 'disconnected') {\n      log.debug('Removing Track event reemitters');\n      signaling.removeListener('stateChanged', stateChanged);\n      participant.tracks.forEach(function (track) {\n        participant._trackEventReemitters.get(track._id).forEach(function (reemitter, event) {\n          track.removeListener(event, reemitter);\n        });\n      });\n\n      participant._trackEventReemitters.clear();\n\n      participant.trackPublications.forEach(function (publication) {\n        participant._trackPublicationEventReemitters.get(publication.trackSid).forEach(function (reemitter, event) {\n          publication.removeListener(event, reemitter);\n        });\n      });\n\n      participant._trackPublicationEventReemitters.clear();\n    }\n  });\n}\n/**\n * Re-emit {@link Track} events.\n * @param {Participant} participant\n * @param {Track} track\n * @private\n */\n\n\nfunction reemitTrackEvents(participant, track) {\n  var trackEventReemitters = new Map();\n\n  if (participant.state === 'disconnected') {\n    return;\n  }\n\n  participant._getTrackEvents().forEach(function (eventPair) {\n    var trackEvent = eventPair[0];\n    var participantEvent = eventPair[1];\n    trackEventReemitters.set(trackEvent, function () {\n      var args = [participantEvent].concat([].slice.call(arguments));\n      return participant.emit.apply(participant, _toConsumableArray(args));\n    });\n    track.on(trackEvent, trackEventReemitters.get(trackEvent));\n  });\n\n  participant._trackEventReemitters.set(track._id, trackEventReemitters);\n}\n/**\n * Re-emit {@link TrackPublication} events.\n * @private\n * @param {Participant} participant\n * @param {TrackPublication} publication\n */\n\n\nfunction reemitTrackPublicationEvents(participant, publication) {\n  var publicationEventReemitters = new Map();\n\n  if (participant.state === 'disconnected') {\n    return;\n  }\n\n  participant._getTrackPublicationEvents().forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        publicationEvent = _ref2[0],\n        participantEvent = _ref2[1];\n\n    publicationEventReemitters.set(publicationEvent, function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      participant.emit.apply(participant, [participantEvent].concat(args, [publication]));\n    });\n    publication.on(publicationEvent, publicationEventReemitters.get(publicationEvent));\n  });\n\n  participant._trackPublicationEventReemitters.set(publication.trackSid, publicationEventReemitters);\n}\n\nmodule.exports = Participant;","map":null,"metadata":{},"sourceType":"script"}