{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview Request Sender\n */\n\n/**\n * @augments SIP\n * @class Class creating a request sender.\n * @param {Object} applicant\n * @param {SIP.UA} ua\n */\n\nmodule.exports = function (SIP) {\n  var RequestSender;\n\n  RequestSender = function RequestSender(applicant, ua) {\n    this.logger = ua.getLogger('sip.requestsender');\n    this.ua = ua;\n    this.applicant = applicant;\n    this.method = applicant.request.method;\n    this.request = applicant.request;\n    this.credentials = null;\n    this.challenged = false;\n    this.staled = false; // If ua is in closing process or even closed just allow sending Bye and ACK\n\n    if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n      this.onTransportError();\n    }\n  };\n  /**\n  * Create the client transaction and send the message.\n  */\n\n\n  RequestSender.prototype = {\n    send: function send() {\n      switch (this.method) {\n        case \"INVITE\":\n          this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n          break;\n\n        case \"ACK\":\n          this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n          break;\n\n        default:\n          this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n      }\n\n      this.clientTransaction.send();\n      return this.clientTransaction;\n    },\n\n    /**\n    * Callback fired when receiving a request timeout error from the client transaction.\n    * To be re-defined by the applicant.\n    * @event\n    */\n    onRequestTimeout: function onRequestTimeout() {\n      this.applicant.onRequestTimeout();\n    },\n\n    /**\n    * Callback fired when receiving a transport error from the client transaction.\n    * To be re-defined by the applicant.\n    * @event\n    */\n    onTransportError: function onTransportError() {\n      this.applicant.onTransportError();\n    },\n\n    /**\n    * Called from client transaction when receiving a correct response to the request.\n    * Authenticate request if needed or pass the response back to the applicant.\n    * @param {SIP.IncomingResponse} response\n    */\n    receiveResponse: function receiveResponse(response) {\n      var cseq,\n          challenge,\n          authorization_header_name,\n          status_code = response.status_code;\n      /*\n      * Authentication\n      * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n      */\n\n      if (status_code === 401 || status_code === 407) {\n        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n        if (response.status_code === 401) {\n          challenge = response.parseHeader('www-authenticate');\n          authorization_header_name = 'authorization';\n        } else {\n          challenge = response.parseHeader('proxy-authenticate');\n          authorization_header_name = 'proxy-authorization';\n        } // Verify it seems a valid challenge.\n\n\n        if (!challenge) {\n          this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n          this.applicant.receiveResponse(response);\n          return;\n        }\n\n        if (!this.challenged || !this.staled && challenge.stale === true) {\n          if (!this.credentials) {\n            this.credentials = this.ua.configuration.authenticationFactory(this.ua);\n          } // Verify that the challenge is really valid.\n\n\n          if (!this.credentials.authenticate(this.request, challenge)) {\n            this.applicant.receiveResponse(response);\n            return;\n          }\n\n          this.challenged = true;\n\n          if (challenge.stale) {\n            this.staled = true;\n          }\n\n          if (response.method === SIP.C.REGISTER) {\n            cseq = this.applicant.cseq += 1;\n          } else if (this.request.dialog) {\n            cseq = this.request.dialog.local_seqnum += 1;\n          } else {\n            cseq = this.request.cseq + 1;\n            this.request.cseq = cseq;\n          }\n\n          this.request.setHeader('cseq', cseq + ' ' + this.method);\n          this.request.setHeader(authorization_header_name, this.credentials.toString());\n          this.send();\n        } else {\n          this.applicant.receiveResponse(response);\n        }\n      } else {\n        this.applicant.receiveResponse(response);\n      }\n    }\n  };\n  SIP.RequestSender = RequestSender;\n};","map":null,"metadata":{},"sourceType":"script"}