{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview MediaStreamManager\n */\n\n/* MediaStreamManager\n * @class Manages the acquisition and release of MediaStreams.\n * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()\n */\n\nmodule.exports = function (SIP, environment) {\n  // Default MediaStreamManager provides single-use streams created with getUserMedia\n  var MediaStreamManager = function MediaStreamManager(logger, defaultMediaHint) {\n    if (!SIP.WebRTC.isSupported()) {\n      throw new SIP.Exceptions.NotSupportedError('Media not supported');\n    }\n\n    this.mediaHint = defaultMediaHint || {\n      constraints: {\n        audio: true,\n        video: true\n      }\n    }; // map of streams to acquisition manner:\n    // true -> passed in as mediaHint.stream\n    // false -> getUserMedia\n\n    this.acquisitions = {};\n  };\n\n  MediaStreamManager.streamId = function (stream) {\n    return stream.getAudioTracks().concat(stream.getVideoTracks()).map(function trackId(track) {\n      return track.id;\n    }).join('');\n  };\n  /**\n   * @param {(Array of) MediaStream} streams - The streams to render\n   *\n   * @param {(Array of) HTMLMediaElement} elements\n   *        - The <audio>/<video> element(s) that should render the streams\n   *\n   * Each stream in streams renders to the corresponding element in elements,\n   * wrapping around elements if needed.\n   */\n\n\n  MediaStreamManager.render = function render(streams, elements) {\n    if (!elements) {\n      return false;\n    }\n\n    if (Array.isArray(elements) && !elements.length) {\n      throw new TypeError('elements must not be empty');\n    }\n\n    function attachMediaStream(element, stream) {\n      element.srcObject = stream;\n    }\n\n    function ensureMediaPlaying(mediaElement) {\n      var interval = 100;\n      mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {\n        if (mediaElement.paused && mediaElement.srcObject) {\n          mediaElement.play();\n        } else {\n          SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);\n        }\n      }, interval);\n    }\n\n    function attachAndPlay(elements, stream, index) {\n      var element = elements[index % elements.length];\n\n      if (typeof element === 'function') {\n        element = element();\n      }\n\n      (environment.attachMediaStream || attachMediaStream)(element, stream);\n      ensureMediaPlaying(element);\n    } // [].concat \"casts\" `elements` into an array\n    // so forEach works even if `elements` was a single element\n\n\n    elements = [].concat(elements);\n    [].concat(streams).forEach(attachAndPlay.bind(null, elements));\n  };\n\n  MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {\n    'acquire': {\n      writable: true,\n      value: function acquire(mediaHint) {\n        mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;\n\n        var saveSuccess = function (isHintStream, streams) {\n          streams = [].concat(streams);\n          streams.forEach(function (stream) {\n            var streamId = MediaStreamManager.streamId(stream);\n            this.acquisitions[streamId] = !!isHintStream;\n          }, this);\n          return SIP.Utils.Promise.resolve(streams);\n        }.bind(this);\n\n        if (mediaHint.stream) {\n          return saveSuccess(true, mediaHint.stream);\n        } else {\n          // Fallback to audio/video enabled if no mediaHint can be found.\n          var constraints = mediaHint.constraints || this.mediaHint && this.mediaHint.constraints || {\n            audio: true,\n            video: true\n          };\n          var deferred = SIP.Utils.defer();\n          /*\n           * Make the call asynchronous, so that ICCs have a chance\n           * to define callbacks to `userMediaRequest`\n           */\n\n          SIP.Timers.setTimeout(function () {\n            this.emit('userMediaRequest', constraints);\n\n            var emitThenCall = function (eventName, callback) {\n              var callbackArgs = Array.prototype.slice.call(arguments, 2); // Emit with all of the arguments from the real callback.\n\n              var newArgs = [eventName].concat(callbackArgs);\n              this.emit.apply(this, newArgs);\n              return callback.apply(null, callbackArgs);\n            }.bind(this);\n\n            if (constraints.audio || constraints.video) {\n              deferred.resolve(SIP.WebRTC.getUserMedia(constraints).then(emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)), emitThenCall.bind(this, 'userMediaFailed', function (e) {\n                throw e;\n              })));\n            } else {\n              // Local streams were explicitly excluded.\n              deferred.resolve([]);\n            }\n          }.bind(this), 0);\n          return deferred.promise;\n        }\n      }\n    },\n    'release': {\n      writable: true,\n      value: function release(streams) {\n        streams = [].concat(streams);\n        streams.forEach(function (stream) {\n          var streamId = MediaStreamManager.streamId(stream);\n\n          if (this.acquisitions[streamId] === false) {\n            stream.getTracks().forEach(function (track) {\n              track.stop();\n            });\n          }\n\n          delete this.acquisitions[streamId];\n        }, this);\n      }\n    }\n  }); // Return since it will be assigned to a variable.\n\n  return MediaStreamManager;\n};","map":null,"metadata":{},"sourceType":"script"}