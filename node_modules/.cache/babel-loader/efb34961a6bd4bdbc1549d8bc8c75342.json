{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (SIP) {\n  var RegisterContext;\n\n  RegisterContext = function RegisterContext(ua) {\n    var params = {},\n        regId = 1;\n    this.registrar = ua.configuration.registrarServer;\n    this.expires = ua.configuration.registerExpires; // Contact header\n\n    this.contact = ua.contact.toString();\n\n    if (regId) {\n      this.contact += ';reg-id=' + regId;\n      this.contact += ';+sip.instance=\"<urn:uuid:' + ua.configuration.instanceId + '>\"';\n    } // Call-ID and CSeq values RFC3261 10.2\n\n\n    this.call_id = SIP.Utils.createRandomToken(22);\n    this.cseq = 80;\n    this.to_uri = ua.configuration.uri;\n    params.to_uri = this.to_uri;\n    params.to_displayName = ua.configuration.displayName;\n    params.call_id = this.call_id;\n    params.cseq = this.cseq; // Extends ClientContext\n\n    SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {\n      params: params\n    }]);\n    this.registrationTimer = null;\n    this.registrationExpiredTimer = null; // Set status\n\n    this.registered = false;\n    this.logger = ua.getLogger('sip.registercontext');\n  };\n\n  RegisterContext.prototype = {\n    register: function register(options) {\n      var self = this,\n          extraHeaders; // Handle Options\n\n      this.options = options || {};\n      extraHeaders = (this.options.extraHeaders || []).slice();\n      extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n      extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString()); // Save original extraHeaders to be used in .close\n\n      this.closeHeaders = this.options.closeWithHeaders ? (this.options.extraHeaders || []).slice() : [];\n\n      this.receiveResponse = function (response) {\n        var contact,\n            expires,\n            contacts = response.getHeaders('contact').length,\n            cause; // Discard responses to older REGISTER/un-REGISTER requests.\n\n        if (response.cseq !== this.cseq) {\n          return;\n        } // Clear registration timer\n\n\n        if (this.registrationTimer !== null) {\n          SIP.Timers.clearTimeout(this.registrationTimer);\n          this.registrationTimer = null;\n        }\n\n        switch (true) {\n          case /^1[0-9]{2}$/.test(response.status_code):\n            this.emit('progress', response);\n            break;\n\n          case /^2[0-9]{2}$/.test(response.status_code):\n            this.emit('accepted', response);\n\n            if (response.hasHeader('expires')) {\n              expires = response.getHeader('expires');\n            }\n\n            if (this.registrationExpiredTimer !== null) {\n              SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n              this.registrationExpiredTimer = null;\n            } // Search the Contact pointing to us and update the expires value accordingly.\n\n\n            if (!contacts) {\n              this.logger.warn('no Contact header in response to REGISTER, response ignored');\n              break;\n            }\n\n            while (contacts--) {\n              contact = response.parseHeader('contact', contacts);\n\n              if (contact.uri.user === this.ua.contact.uri.user) {\n                expires = contact.getParam('expires');\n                break;\n              } else {\n                contact = null;\n              }\n            }\n\n            if (!contact) {\n              this.logger.warn('no Contact header pointing to us, response ignored');\n              break;\n            }\n\n            if (!expires) {\n              expires = this.expires;\n            } // Re-Register before the expiration interval has elapsed.\n            // For that, decrease the expires value. ie: 3 seconds\n\n\n            this.registrationTimer = SIP.Timers.setTimeout(function () {\n              self.registrationTimer = null;\n              self.register(self.options);\n            }, expires * 1000 - 3000);\n            this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n              self.logger.warn('registration expired');\n\n              if (self.registered) {\n                self.unregistered(null, SIP.C.causes.EXPIRES);\n              }\n            }, expires * 1000); //Save gruu values\n\n            if (contact.hasParam('temp-gruu')) {\n              this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g, ''));\n            }\n\n            if (contact.hasParam('pub-gruu')) {\n              this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g, ''));\n            }\n\n            this.registered = true;\n            this.emit('registered', response || null);\n            break;\n          // Interval too brief RFC3261 10.2.8\n\n          case /^423$/.test(response.status_code):\n            if (response.hasHeader('min-expires')) {\n              // Increase our registration interval to the suggested minimum\n              this.expires = response.getHeader('min-expires'); // Attempt the registration again immediately\n\n              this.register(this.options);\n            } else {\n              //This response MUST contain a Min-Expires header field\n              this.logger.warn('423 response received for REGISTER without Min-Expires');\n              this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n            }\n\n            break;\n\n          default:\n            cause = SIP.Utils.sipErrorCause(response.status_code);\n            this.registrationFailure(response, cause);\n        }\n      };\n\n      this.onRequestTimeout = function () {\n        this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n      };\n\n      this.onTransportError = function () {\n        this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n      };\n\n      this.cseq++;\n      this.request.cseq = this.cseq;\n      this.request.setHeader('cseq', this.cseq + ' REGISTER');\n      this.request.extraHeaders = extraHeaders;\n      this.send();\n    },\n    registrationFailure: function registrationFailure(response, cause) {\n      this.emit('failed', response || null, cause || null);\n    },\n    onTransportClosed: function onTransportClosed() {\n      this.registered_before = this.registered;\n\n      if (this.registrationTimer !== null) {\n        SIP.Timers.clearTimeout(this.registrationTimer);\n        this.registrationTimer = null;\n      }\n\n      if (this.registrationExpiredTimer !== null) {\n        SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n        this.registrationExpiredTimer = null;\n      }\n\n      if (this.registered) {\n        this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n      }\n    },\n    onTransportConnected: function onTransportConnected() {\n      this.register(this.options);\n    },\n    close: function close() {\n      var options = {\n        all: false,\n        extraHeaders: this.closeHeaders\n      };\n      this.registered_before = this.registered;\n      this.unregister(options);\n    },\n    unregister: function unregister(options) {\n      var extraHeaders;\n      options = options || {};\n\n      if (!this.registered && !options.all) {\n        this.logger.warn('already unregistered');\n        return;\n      }\n\n      extraHeaders = (options.extraHeaders || []).slice();\n      this.registered = false; // Clear the registration timer.\n\n      if (this.registrationTimer !== null) {\n        SIP.Timers.clearTimeout(this.registrationTimer);\n        this.registrationTimer = null;\n      }\n\n      if (options.all) {\n        extraHeaders.push('Contact: *');\n        extraHeaders.push('Expires: 0');\n      } else {\n        extraHeaders.push('Contact: ' + this.contact + ';expires=0');\n      }\n\n      this.receiveResponse = function (response) {\n        var cause;\n\n        switch (true) {\n          case /^1[0-9]{2}$/.test(response.status_code):\n            this.emit('progress', response);\n            break;\n\n          case /^2[0-9]{2}$/.test(response.status_code):\n            this.emit('accepted', response);\n\n            if (this.registrationExpiredTimer !== null) {\n              SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n              this.registrationExpiredTimer = null;\n            }\n\n            this.unregistered(response);\n            break;\n\n          default:\n            cause = SIP.Utils.sipErrorCause(response.status_code);\n            this.unregistered(response, cause);\n        }\n      };\n\n      this.onRequestTimeout = function () {// Not actually unregistered...\n        //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n      };\n\n      this.onTransportError = function () {// Not actually unregistered...\n        //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n      };\n\n      this.cseq++;\n      this.request.cseq = this.cseq;\n      this.request.setHeader('cseq', this.cseq + ' REGISTER');\n      this.request.extraHeaders = extraHeaders;\n      this.send();\n    },\n    unregistered: function unregistered(response, cause) {\n      this.registered = false;\n      this.emit('unregistered', response || null, cause || null);\n    }\n  };\n  SIP.RegisterContext = RegisterContext;\n};","map":null,"metadata":{},"sourceType":"script"}