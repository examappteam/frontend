{"ast":null,"code":"/* eslint new-cap:0, no-console:0 */\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar constants = require('./constants');\n\nvar DEFAULT_LOG_LEVEL = constants.DEFAULT_LOG_LEVEL;\n\nvar E = require('./constants').typeErrors;\n\nvar deprecationWarningsByComponentConstructor = void 0;\n\nfunction getDeprecationWarnings(componentConstructor) {\n  deprecationWarningsByComponentConstructor = deprecationWarningsByComponentConstructor || new Map();\n\n  if (deprecationWarningsByComponentConstructor.has(componentConstructor)) {\n    return deprecationWarningsByComponentConstructor.get(componentConstructor);\n  }\n\n  var deprecationWarnings = new Set();\n  deprecationWarningsByComponentConstructor.set(componentConstructor, deprecationWarnings);\n  return deprecationWarnings;\n}\n/**\n * Selectively outputs messages to console.log based on specified minimum module\n * specific log levels.\n *\n * NOTE: The values in the logLevels object passed to the constructor is changed\n *       by subsequent calls to {@link Log#setLevels}.\n */\n\n\nvar Log = function () {\n  /**\n   * Construct a new {@link Log} object.\n   * @param {String} moduleName - Name of the logging module (webrtc/media/signaling)\n   * @param {object} component - Component owning this instance of {@link Log}\n   * @param {LogLevels} logLevels - Logging levels. See {@link LogLevels}\n   */\n  function Log(moduleName, component, logLevels) {\n    _classCallCheck(this, Log);\n\n    if (typeof moduleName !== 'string') {\n      throw E.INVALID_TYPE('moduleName', 'string');\n    }\n\n    if (!component) {\n      throw E.REQUIRED_ARGUMENT('component');\n    }\n\n    if ((typeof logLevels === 'undefined' ? 'undefined' : _typeof(logLevels)) !== 'object') {\n      logLevels = {};\n    }\n\n    validateLogLevels(logLevels);\n    /* istanbul ignore next */\n\n    Object.defineProperties(this, {\n      _component: {\n        value: component\n      },\n      _logLevels: {\n        value: logLevels\n      },\n      _warnings: {\n        value: new Set()\n      },\n      logLevel: {\n        get: function get() {\n          return Log.getLevelByName(logLevels[moduleName] || DEFAULT_LOG_LEVEL);\n        }\n      },\n      name: {\n        get: component.toString.bind(component)\n      }\n    });\n  }\n  /**\n   * Get the log level (number) by its name (string)\n   * @param {String} name - Name of the log level\n   * @returns {Number} Requested log level\n   * @throws {TwilioError} INVALID_LOG_LEVEL (32056)\n   * @public\n   */\n\n\n  _createClass(Log, [{\n    key: 'createLog',\n\n    /**\n     * Create a child {@link Log} instance with this._logLevels\n     * @param moduleName - Name of the logging module\n     * @param component - Component owning this instance of {@link Log}\n     * @returns {Log} this\n     */\n    value: function createLog(moduleName, component) {\n      return new Log(moduleName, component, this._logLevels);\n    }\n    /**\n     * Set new log levels.\n     * This changes the levels for all its ancestors,\n     * siblings, and children and descendants instances of {@link Log}.\n     * @param {LogLevels} levels - New log levels\n     * @throws {TwilioError} INVALID_ARGUMENT\n     * @returns {Log} this\n     */\n\n  }, {\n    key: 'setLevels',\n    value: function setLevels(levels) {\n      validateLogLevels(levels);\n      Object.assign(this._logLevels, levels);\n      return this;\n    }\n    /**\n     * Log a message using the console method appropriate for the specified logLevel\n     * @param {Number} logLevel - Log level of the message being logged\n     * @param {String} message - Message(s) to log\n     * @returns {Log} This instance of {@link Log}\n     * @public\n     */\n\n  }, {\n    key: 'log',\n    value: function log(logLevel, message) {\n      var logSpec = Log._levels[logLevel]; // eslint-disable-next-line no-use-before-define\n\n      if (!logSpec) {\n        throw E.INVALID_VALUE('logLevel', LOG_LEVEL_VALUES);\n      }\n\n      if (this.logLevel <= logLevel) {\n        var levelName = logSpec.name;\n        var prefix = new Date().toISOString().split('T').concat(['|', levelName, 'in', this.name + ':']);\n        logSpec.logFn.apply(console, prefix.concat(message));\n      }\n\n      return this;\n    }\n    /**\n     * Log a debug message using console.log\n     * @param {...String} messages - Message(s) to pass to console.log\n     * @returns {Log} This instance of {@link Log}\n     * @public\n     */\n\n  }, {\n    key: 'debug',\n    value: function debug() {\n      return this.log(Log.DEBUG, [].slice.call(arguments));\n    }\n    /**\n     * Log a deprecation warning. Deprecation warnings are logged as warnings and\n     * they are only ever logged once.\n     * @param {String} deprecationWarning - The deprecation warning\n     * @returns {Log} This instance of {@link Log}\n     * @public\n     */\n\n  }, {\n    key: 'deprecated',\n    value: function deprecated(deprecationWarning) {\n      var deprecationWarnings = getDeprecationWarnings(this._component.constructor);\n\n      if (deprecationWarnings.has(deprecationWarning)) {\n        return this;\n      }\n\n      deprecationWarnings.add(deprecationWarning);\n      return this.warn(deprecationWarning);\n    }\n    /**\n     * Log an info message using console.info\n     * @param {...String} messages - Message(s) to pass to console.info\n     * @returns {Log} This instance of {@link Log}\n     * @public\n     */\n\n  }, {\n    key: 'info',\n    value: function info() {\n      return this.log(Log.INFO, [].slice.call(arguments));\n    }\n    /**\n     * Log a warn message using console.warn\n     * @param {...String} messages - Message(s) to pass to console.warn\n     * @returns {Log} This instance of {@link Log}\n     * @public\n     */\n\n  }, {\n    key: 'warn',\n    value: function warn() {\n      return this.log(Log.WARN, [].slice.call(arguments));\n    }\n    /**\n     * Log a warning once.\n     * @param {String} warning\n     * @returns {Log} This instance of {@link Log}\n     * @public\n     */\n\n  }, {\n    key: 'warnOnce',\n    value: function warnOnce(warning) {\n      if (this._warnings.has(warning)) {\n        return this;\n      }\n\n      this._warnings.add(warning);\n\n      return this.warn(warning);\n    }\n    /**\n     * Log an error message using console.error\n     * @param {...String} messages - Message(s) to pass to console.error\n     * @returns {Log} This instance of {@link Log}\n     * @public\n     */\n\n  }, {\n    key: 'error',\n    value: function error() {\n      return this.log(Log.ERROR, [].slice.call(arguments));\n    }\n    /**\n     * Log an error message using console.error and throw an exception\n     * @param {TwilioError} error - Error to throw\n     * @param {String} customMessage - Custom message for the error\n     * @public\n     */\n\n  }, {\n    key: 'throw',\n    value: function _throw(error, customMessage) {\n      if (error.clone) {\n        error = error.clone(customMessage);\n      }\n\n      this.log(Log.ERROR, error);\n      throw error;\n    }\n  }], [{\n    key: 'getLevelByName',\n    value: function getLevelByName(name) {\n      if (!isNaN(name)) {\n        return parseInt(name, 10);\n      }\n\n      name = name.toUpperCase();\n      validateLogLevel(name);\n      return Log[name];\n    }\n  }]);\n\n  return Log;\n}(); // Singleton Constants\n\n/* eslint key-spacing:0 */\n\n/* istanbul ignore next */\n\n\nObject.defineProperties(Log, {\n  DEBUG: {\n    value: 0\n  },\n  INFO: {\n    value: 1\n  },\n  WARN: {\n    value: 2\n  },\n  ERROR: {\n    value: 3\n  },\n  OFF: {\n    value: 4\n  },\n  _levels: {\n    value: [{\n      name: 'DEBUG',\n      logFn: console.log\n    }, {\n      name: 'INFO',\n      logFn: console.info\n    }, {\n      name: 'WARN',\n      logFn: console.warn\n    }, {\n      name: 'ERROR',\n      logFn: console.error\n    }, {\n      name: 'OFF',\n      logFn: function noop() {}\n    }]\n  }\n});\nvar LOG_LEVELS_SET = {};\nvar LOG_LEVEL_VALUES = [];\n\nvar LOG_LEVEL_NAMES = Log._levels.map(function (level, i) {\n  LOG_LEVELS_SET[level.name] = true;\n  LOG_LEVEL_VALUES.push(i);\n  return level.name;\n});\n\nfunction validateLogLevel(level) {\n  if (!(level in LOG_LEVELS_SET)) {\n    throw E.INVALID_VALUE('level', LOG_LEVEL_NAMES);\n  }\n}\n\nfunction validateLogLevels(levels) {\n  Object.keys(levels).forEach(function (moduleName) {\n    validateLogLevel(levels[moduleName].toUpperCase());\n  });\n}\n\nmodule.exports = Log;","map":null,"metadata":{},"sourceType":"script"}