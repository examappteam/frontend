{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview SIP Message Parser\n */\n\n/**\n * Extract and parse every header of a SIP message.\n * @augments SIP\n * @namespace\n */\n\nmodule.exports = function (SIP) {\n  var Parser;\n\n  function getHeader(data, headerStart) {\n    var // 'start' position of the header.\n    start = headerStart,\n        // 'end' position of the header.\n    end = 0,\n        // 'partial end' position of the header.\n    partialEnd = 0; //End of message.\n\n    if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n      return -2;\n    }\n\n    while (end === 0) {\n      // Partial End of Header.\n      partialEnd = data.indexOf('\\r\\n', start); // 'indexOf' returns -1 if the value to be found never occurs.\n\n      if (partialEnd === -1) {\n        return partialEnd;\n      }\n\n      if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n        // Not the end of the message. Continue from the next position.\n        start = partialEnd + 2;\n      } else {\n        end = partialEnd;\n      }\n    }\n\n    return end;\n  }\n\n  function parseHeader(message, data, headerStart, headerEnd) {\n    var header,\n        idx,\n        length,\n        parsed,\n        hcolonIndex = data.indexOf(':', headerStart),\n        headerName = data.substring(headerStart, hcolonIndex).trim(),\n        headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // If header-field is well-known, parse it.\n\n    switch (headerName.toLowerCase()) {\n      case 'via':\n      case 'v':\n        message.addHeader('via', headerValue);\n\n        if (message.getHeaders('via').length === 1) {\n          parsed = message.parseHeader('Via');\n\n          if (parsed) {\n            message.via = parsed;\n            message.via_branch = parsed.branch;\n          }\n        } else {\n          parsed = 0;\n        }\n\n        break;\n\n      case 'from':\n      case 'f':\n        message.setHeader('from', headerValue);\n        parsed = message.parseHeader('from');\n\n        if (parsed) {\n          message.from = parsed;\n          message.from_tag = parsed.getParam('tag');\n        }\n\n        break;\n\n      case 'to':\n      case 't':\n        message.setHeader('to', headerValue);\n        parsed = message.parseHeader('to');\n\n        if (parsed) {\n          message.to = parsed;\n          message.to_tag = parsed.getParam('tag');\n        }\n\n        break;\n\n      case 'record-route':\n        parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n\n        if (parsed === -1) {\n          parsed = undefined;\n          break;\n        }\n\n        length = parsed.length;\n\n        for (idx = 0; idx < length; idx++) {\n          header = parsed[idx];\n          message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n          message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n        }\n\n        break;\n\n      case 'call-id':\n      case 'i':\n        message.setHeader('call-id', headerValue);\n        parsed = message.parseHeader('call-id');\n\n        if (parsed) {\n          message.call_id = headerValue;\n        }\n\n        break;\n\n      case 'contact':\n      case 'm':\n        parsed = SIP.Grammar.parse(headerValue, 'Contact');\n\n        if (parsed === -1) {\n          parsed = undefined;\n          break;\n        }\n\n        length = parsed.length;\n\n        for (idx = 0; idx < length; idx++) {\n          header = parsed[idx];\n          message.addHeader('contact', headerValue.substring(header.position, header.offset));\n          message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n        }\n\n        break;\n\n      case 'content-length':\n      case 'l':\n        message.setHeader('content-length', headerValue);\n        parsed = message.parseHeader('content-length');\n        break;\n\n      case 'content-type':\n      case 'c':\n        message.setHeader('content-type', headerValue);\n        parsed = message.parseHeader('content-type');\n        break;\n\n      case 'cseq':\n        message.setHeader('cseq', headerValue);\n        parsed = message.parseHeader('cseq');\n\n        if (parsed) {\n          message.cseq = parsed.value;\n        }\n\n        if (message instanceof SIP.IncomingResponse) {\n          message.method = parsed.method;\n        }\n\n        break;\n\n      case 'max-forwards':\n        message.setHeader('max-forwards', headerValue);\n        parsed = message.parseHeader('max-forwards');\n        break;\n\n      case 'www-authenticate':\n        message.setHeader('www-authenticate', headerValue);\n        parsed = message.parseHeader('www-authenticate');\n        break;\n\n      case 'proxy-authenticate':\n        message.setHeader('proxy-authenticate', headerValue);\n        parsed = message.parseHeader('proxy-authenticate');\n        break;\n\n      case 'refer-to':\n      case 'r':\n        message.setHeader('refer-to', headerValue);\n        parsed = message.parseHeader('refer-to');\n\n        if (parsed) {\n          message.refer_to = parsed;\n        }\n\n        break;\n\n      default:\n        // Do not parse this header.\n        message.setHeader(headerName, headerValue);\n        parsed = 0;\n    }\n\n    if (parsed === undefined) {\n      return {\n        error: 'error parsing header \"' + headerName + '\"'\n      };\n    } else {\n      return true;\n    }\n  }\n  /** Parse SIP Message\n   * @function\n   * @param {String} message SIP message.\n   * @param {Object} logger object.\n   * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n   */\n\n\n  Parser = {};\n\n  Parser.parseMessage = function (data, ua) {\n    var message,\n        firstLine,\n        contentLength,\n        bodyStart,\n        parsed,\n        headerStart = 0,\n        headerEnd = data.indexOf('\\r\\n'),\n        logger = ua.getLogger('sip.parser');\n\n    if (headerEnd === -1) {\n      logger.warn('no CRLF found, not a SIP message, discarded');\n      return;\n    } // Parse first line. Check if it is a Request or a Reply.\n\n\n    firstLine = data.substring(0, headerEnd);\n    parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n\n    if (parsed === -1) {\n      logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n      return;\n    } else if (!parsed.status_code) {\n      message = new SIP.IncomingRequest(ua);\n      message.method = parsed.method;\n      message.ruri = parsed.uri;\n    } else {\n      message = new SIP.IncomingResponse(ua);\n      message.status_code = parsed.status_code;\n      message.reason_phrase = parsed.reason_phrase;\n    }\n\n    message.data = data;\n    headerStart = headerEnd + 2;\n    /* Loop over every line in data. Detect the end of each header and parse\n    * it or simply add to the headers collection.\n    */\n\n    while (true) {\n      headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.\n\n      if (headerEnd === -2) {\n        bodyStart = headerStart + 2;\n        break;\n      } // data.indexOf returned -1 due to a malformed message.\n      else if (headerEnd === -1) {\n          logger.error('malformed message');\n          return;\n        }\n\n      parsed = parseHeader(message, data, headerStart, headerEnd);\n\n      if (parsed !== true) {\n        logger.error(parsed.error);\n        return;\n      }\n\n      headerStart = headerEnd + 2;\n    }\n    /* RFC3261 18.3.\n     * If there are additional bytes in the transport packet\n     * beyond the end of the body, they MUST be discarded.\n     */\n\n\n    if (message.hasHeader('content-length')) {\n      contentLength = message.getHeader('content-length');\n      message.body = data.substr(bodyStart, contentLength);\n    } else {\n      message.body = data.substring(bodyStart);\n    }\n\n    return message;\n  };\n\n  SIP.Parser = Parser;\n};","map":null,"metadata":{},"sourceType":"script"}