{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview SIP Transactions\n */\n\n/**\n * SIP Transactions module.\n * @augments SIP\n */\n\nmodule.exports = function (SIP) {\n  var C = {\n    // Transaction states\n    STATUS_TRYING: 1,\n    STATUS_PROCEEDING: 2,\n    STATUS_CALLING: 3,\n    STATUS_ACCEPTED: 4,\n    STATUS_COMPLETED: 5,\n    STATUS_TERMINATED: 6,\n    STATUS_CONFIRMED: 7,\n    // Transaction types\n    NON_INVITE_CLIENT: 'nict',\n    NON_INVITE_SERVER: 'nist',\n    INVITE_CLIENT: 'ict',\n    INVITE_SERVER: 'ist'\n  };\n\n  function buildViaHeader(request_sender, transport, id) {\n    var via;\n    via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n    via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;\n\n    if (request_sender.ua.configuration.forceRport) {\n      via += ';rport';\n    }\n\n    return via;\n  }\n  /**\n  * @augments SIP.Transactions\n  * @class Non Invite Client Transaction\n  * @param {SIP.RequestSender} request_sender\n  * @param {SIP.OutgoingRequest} request\n  * @param {SIP.Transport} transport\n  */\n\n\n  var NonInviteClientTransaction = function NonInviteClientTransaction(request_sender, request, transport) {\n    var via;\n    this.type = C.NON_INVITE_CLIENT;\n    this.transport = transport;\n    this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    this.request_sender = request_sender;\n    this.request = request;\n    this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n    via = buildViaHeader(request_sender, transport, this.id);\n    this.request.setHeader('via', via);\n    this.request_sender.ua.newTransaction(this);\n  };\n\n  NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\n  NonInviteClientTransaction.prototype.stateChanged = function (state) {\n    this.state = state;\n    this.emit('stateChanged');\n  };\n\n  NonInviteClientTransaction.prototype.send = function () {\n    var tr = this;\n    this.stateChanged(C.STATUS_TRYING);\n    this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n\n    if (!this.transport.send(this.request)) {\n      this.onTransportError();\n    }\n  };\n\n  NonInviteClientTransaction.prototype.onTransportError = function () {\n    this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n    SIP.Timers.clearTimeout(this.F);\n    SIP.Timers.clearTimeout(this.K);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n    this.request_sender.onTransportError();\n  };\n\n  NonInviteClientTransaction.prototype.timer_F = function () {\n    this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n    this.request_sender.onRequestTimeout();\n  };\n\n  NonInviteClientTransaction.prototype.timer_K = function () {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n  };\n\n  NonInviteClientTransaction.prototype.receiveResponse = function (response) {\n    var tr = this,\n        status_code = response.status_code;\n\n    if (status_code < 200) {\n      switch (this.state) {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n          this.request_sender.receiveResponse(response);\n          break;\n      }\n    } else {\n      switch (this.state) {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          SIP.Timers.clearTimeout(this.F);\n\n          if (status_code === 408) {\n            this.request_sender.onRequestTimeout();\n          } else {\n            this.request_sender.receiveResponse(response);\n          }\n\n          this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n          break;\n\n        case C.STATUS_COMPLETED:\n          break;\n      }\n    }\n  };\n  /**\n  * @augments SIP.Transactions\n  * @class Invite Client Transaction\n  * @param {SIP.RequestSender} request_sender\n  * @param {SIP.OutgoingRequest} request\n  * @param {SIP.Transport} transport\n  */\n\n\n  var InviteClientTransaction = function InviteClientTransaction(request_sender, request, transport) {\n    var via,\n        tr = this;\n    this.type = C.INVITE_CLIENT;\n    this.transport = transport;\n    this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    this.request_sender = request_sender;\n    this.request = request;\n    this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n    via = buildViaHeader(request_sender, transport, this.id);\n    this.request.setHeader('via', via);\n    this.request_sender.ua.newTransaction(this); // Add the cancel property to the request.\n    //Will be called from the request instance, not the transaction itself.\n\n    this.request.cancel = function (reason, extraHeaders) {\n      extraHeaders = (extraHeaders || []).slice();\n      var length = extraHeaders.length;\n      var extraHeadersString = null;\n\n      for (var idx = 0; idx < length; idx++) {\n        extraHeadersString = (extraHeadersString || '') + extraHeaders[idx].trim() + '\\r\\n';\n      }\n\n      tr.cancel_request(tr, reason, extraHeadersString);\n    };\n  };\n\n  InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\n  InviteClientTransaction.prototype.stateChanged = function (state) {\n    this.state = state;\n    this.emit('stateChanged');\n  };\n\n  InviteClientTransaction.prototype.send = function () {\n    var tr = this;\n    this.stateChanged(C.STATUS_CALLING);\n    this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n\n    if (!this.transport.send(this.request)) {\n      this.onTransportError();\n    }\n  };\n\n  InviteClientTransaction.prototype.onTransportError = function () {\n    this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n    SIP.Timers.clearTimeout(this.B);\n    SIP.Timers.clearTimeout(this.D);\n    SIP.Timers.clearTimeout(this.M);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n\n    if (this.state !== C.STATUS_ACCEPTED) {\n      this.request_sender.onTransportError();\n    }\n  }; // RFC 6026 7.2\n\n\n  InviteClientTransaction.prototype.timer_M = function () {\n    this.logger.log('Timer M expired for INVITE client transaction ' + this.id);\n\n    if (this.state === C.STATUS_ACCEPTED) {\n      SIP.Timers.clearTimeout(this.B);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.request_sender.ua.destroyTransaction(this);\n    }\n  }; // RFC 3261 17.1.1\n\n\n  InviteClientTransaction.prototype.timer_B = function () {\n    this.logger.log('Timer B expired for INVITE client transaction ' + this.id);\n\n    if (this.state === C.STATUS_CALLING) {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.request_sender.ua.destroyTransaction(this);\n      this.request_sender.onRequestTimeout();\n    }\n  };\n\n  InviteClientTransaction.prototype.timer_D = function () {\n    this.logger.log('Timer D expired for INVITE client transaction ' + this.id);\n    SIP.Timers.clearTimeout(this.B);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n  };\n\n  InviteClientTransaction.prototype.sendACK = function (response) {\n    var tr = this;\n    this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\\r\\n';\n    this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\\r\\n';\n\n    if (this.request.headers['Route']) {\n      this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\\r\\n';\n    }\n\n    this.ack += 'To: ' + response.getHeader('to') + '\\r\\n';\n    this.ack += 'From: ' + this.request.headers['From'].toString() + '\\r\\n';\n    this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\\r\\n';\n    this.ack += 'Content-Length: 0\\r\\n';\n    this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];\n    this.ack += ' ACK\\r\\n\\r\\n';\n    this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);\n    this.transport.send(this.ack);\n  };\n\n  InviteClientTransaction.prototype.cancel_request = function (tr, reason, extraHeaders) {\n    var request = tr.request;\n    this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n    this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n\n    if (this.request.headers['Route']) {\n      this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n    }\n\n    this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n    this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n    this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n    this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] + ' CANCEL\\r\\n';\n\n    if (reason) {\n      this.cancel += 'Reason: ' + reason + '\\r\\n';\n    }\n\n    if (extraHeaders) {\n      this.cancel += extraHeaders;\n    }\n\n    this.cancel += 'Content-Length: 0\\r\\n\\r\\n'; // Send only if a provisional response (>100) has been received.\n\n    if (this.state === C.STATUS_PROCEEDING) {\n      this.transport.send(this.cancel);\n    }\n  };\n\n  InviteClientTransaction.prototype.receiveResponse = function (response) {\n    var tr = this,\n        status_code = response.status_code;\n\n    if (status_code >= 100 && status_code <= 199) {\n      switch (this.state) {\n        case C.STATUS_CALLING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n          this.request_sender.receiveResponse(response);\n\n          if (this.cancel) {\n            this.transport.send(this.cancel);\n          }\n\n          break;\n\n        case C.STATUS_PROCEEDING:\n          this.request_sender.receiveResponse(response);\n          break;\n      }\n    } else if (status_code >= 200 && status_code <= 299) {\n      switch (this.state) {\n        case C.STATUS_CALLING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_ACCEPTED);\n          this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n          this.request_sender.receiveResponse(response);\n          break;\n\n        case C.STATUS_ACCEPTED:\n          this.request_sender.receiveResponse(response);\n          break;\n      }\n    } else if (status_code >= 300 && status_code <= 699) {\n      switch (this.state) {\n        case C.STATUS_CALLING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.sendACK(response);\n          this.request_sender.receiveResponse(response);\n          break;\n\n        case C.STATUS_COMPLETED:\n          this.sendACK(response);\n          break;\n      }\n    }\n  };\n  /**\n   * @augments SIP.Transactions\n   * @class ACK Client Transaction\n   * @param {SIP.RequestSender} request_sender\n   * @param {SIP.OutgoingRequest} request\n   * @param {SIP.Transport} transport\n   */\n\n\n  var AckClientTransaction = function AckClientTransaction(request_sender, request, transport) {\n    var via;\n    this.transport = transport;\n    this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    this.request_sender = request_sender;\n    this.request = request;\n    this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n    via = buildViaHeader(request_sender, transport, this.id);\n    this.request.setHeader('via', via);\n  };\n\n  AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\n  AckClientTransaction.prototype.send = function () {\n    if (!this.transport.send(this.request)) {\n      this.onTransportError();\n    }\n  };\n\n  AckClientTransaction.prototype.onTransportError = function () {\n    this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n    this.request_sender.onTransportError();\n  };\n  /**\n  * @augments SIP.Transactions\n  * @class Non Invite Server Transaction\n  * @param {SIP.IncomingRequest} request\n  * @param {SIP.UA} ua\n  */\n\n\n  var NonInviteServerTransaction = function NonInviteServerTransaction(request, ua) {\n    this.type = C.NON_INVITE_SERVER;\n    this.id = request.via_branch;\n    this.request = request;\n    this.transport = request.transport;\n    this.ua = ua;\n    this.last_response = '';\n    request.server_transaction = this;\n    this.logger = ua.getLogger('sip.transaction.nist', this.id);\n    this.state = C.STATUS_TRYING;\n    ua.newTransaction(this);\n  };\n\n  NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\n  NonInviteServerTransaction.prototype.stateChanged = function (state) {\n    this.state = state;\n    this.emit('stateChanged');\n  };\n\n  NonInviteServerTransaction.prototype.timer_J = function () {\n    this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  };\n\n  NonInviteServerTransaction.prototype.onTransportError = function () {\n    if (!this.transportError) {\n      this.transportError = true;\n      this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n      SIP.Timers.clearTimeout(this.J);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  };\n\n  NonInviteServerTransaction.prototype.receiveResponse = function (status_code, response) {\n    var tr = this;\n    var deferred = SIP.Utils.defer();\n\n    if (status_code === 100) {\n      /* RFC 4320 4.1\n       * 'A SIP element MUST NOT\n       * send any provisional response with a\n       * Status-Code other than 100 to a non-INVITE request.'\n       */\n      switch (this.state) {\n        case C.STATUS_TRYING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n          }\n\n          break;\n\n        case C.STATUS_PROCEEDING:\n          this.last_response = response;\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n            deferred.reject();\n          } else {\n            deferred.resolve();\n          }\n\n          break;\n      }\n    } else if (status_code >= 200 && status_code <= 699) {\n      switch (this.state) {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.last_response = response;\n          this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n            deferred.reject();\n          } else {\n            deferred.resolve();\n          }\n\n          break;\n\n        case C.STATUS_COMPLETED:\n          break;\n      }\n    }\n\n    return deferred.promise;\n  };\n  /**\n  * @augments SIP.Transactions\n  * @class Invite Server Transaction\n  * @param {SIP.IncomingRequest} request\n  * @param {SIP.UA} ua\n  */\n\n\n  var InviteServerTransaction = function InviteServerTransaction(request, ua) {\n    this.type = C.INVITE_SERVER;\n    this.id = request.via_branch;\n    this.request = request;\n    this.transport = request.transport;\n    this.ua = ua;\n    this.last_response = '';\n    request.server_transaction = this;\n    this.logger = ua.getLogger('sip.transaction.ist', this.id);\n    this.state = C.STATUS_PROCEEDING;\n    ua.newTransaction(this);\n    this.resendProvisionalTimer = null;\n    request.reply(100);\n  };\n\n  InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n\n  InviteServerTransaction.prototype.stateChanged = function (state) {\n    this.state = state;\n    this.emit('stateChanged');\n  };\n\n  InviteServerTransaction.prototype.timer_H = function () {\n    this.logger.log('Timer H expired for INVITE server transaction ' + this.id);\n\n    if (this.state === C.STATUS_COMPLETED) {\n      this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n    }\n\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  };\n\n  InviteServerTransaction.prototype.timer_I = function () {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }; // RFC 6026 7.1\n\n\n  InviteServerTransaction.prototype.timer_L = function () {\n    this.logger.log('Timer L expired for INVITE server transaction ' + this.id);\n\n    if (this.state === C.STATUS_ACCEPTED) {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  };\n\n  InviteServerTransaction.prototype.onTransportError = function () {\n    if (!this.transportError) {\n      this.transportError = true;\n      this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n\n      if (this.resendProvisionalTimer !== null) {\n        SIP.Timers.clearInterval(this.resendProvisionalTimer);\n        this.resendProvisionalTimer = null;\n      }\n\n      SIP.Timers.clearTimeout(this.L);\n      SIP.Timers.clearTimeout(this.H);\n      SIP.Timers.clearTimeout(this.I);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  };\n\n  InviteServerTransaction.prototype.resend_provisional = function () {\n    if (!this.transport.send(this.last_response)) {\n      this.onTransportError();\n    }\n  }; // INVITE Server Transaction RFC 3261 17.2.1\n\n\n  InviteServerTransaction.prototype.receiveResponse = function (status_code, response) {\n    var tr = this;\n    var deferred = SIP.Utils.defer();\n\n    if (status_code >= 100 && status_code <= 199) {\n      switch (this.state) {\n        case C.STATUS_PROCEEDING:\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n          }\n\n          this.last_response = response;\n          break;\n      }\n    }\n\n    if (status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n      // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n      if (this.resendProvisionalTimer === null) {\n        this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr), SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n      }\n    } else if (status_code >= 200 && status_code <= 299) {\n      switch (this.state) {\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_ACCEPTED);\n          this.last_response = response;\n          this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n\n          if (this.resendProvisionalTimer !== null) {\n            SIP.Timers.clearInterval(this.resendProvisionalTimer);\n            this.resendProvisionalTimer = null;\n          }\n\n        /* falls through */\n\n        case C.STATUS_ACCEPTED:\n          // Note that this point will be reached for proceeding tr.state also.\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n            deferred.reject();\n          } else {\n            deferred.resolve();\n          }\n\n          break;\n      }\n    } else if (status_code >= 300 && status_code <= 699) {\n      switch (this.state) {\n        case C.STATUS_PROCEEDING:\n          if (this.resendProvisionalTimer !== null) {\n            SIP.Timers.clearInterval(this.resendProvisionalTimer);\n            this.resendProvisionalTimer = null;\n          }\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n            deferred.reject();\n          } else {\n            this.stateChanged(C.STATUS_COMPLETED);\n            this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n            deferred.resolve();\n          }\n\n          break;\n      }\n    }\n\n    return deferred.promise;\n  };\n  /**\n   * @function\n   * @param {SIP.UA} ua\n   * @param {SIP.IncomingRequest} request\n   *\n   * @return {boolean}\n   * INVITE:\n   *  _true_ if retransmission\n   *  _false_ new request\n   *\n   * ACK:\n   *  _true_  ACK to non2xx response\n   *  _false_ ACK must be passed to TU (accepted state)\n   *          ACK to 2xx response\n   *\n   * CANCEL:\n   *  _true_  no matching invite transaction\n   *  _false_ matching invite transaction and no final response sent\n   *\n   * OTHER:\n   *  _true_  retransmission\n   *  _false_ new request\n   */\n\n\n  var checkTransaction = function checkTransaction(ua, request) {\n    var tr;\n\n    switch (request.method) {\n      case SIP.C.INVITE:\n        tr = ua.transactions.ist[request.via_branch];\n\n        if (tr) {\n          switch (tr.state) {\n            case C.STATUS_PROCEEDING:\n              tr.transport.send(tr.last_response);\n              break;\n            // RFC 6026 7.1 Invite retransmission\n            //received while in C.STATUS_ACCEPTED state. Absorb it.\n\n            case C.STATUS_ACCEPTED:\n              break;\n          }\n\n          return true;\n        }\n\n        break;\n\n      case SIP.C.ACK:\n        tr = ua.transactions.ist[request.via_branch]; // RFC 6026 7.1\n\n        if (tr) {\n          if (tr.state === C.STATUS_ACCEPTED) {\n            return false;\n          } else if (tr.state === C.STATUS_COMPLETED) {\n            tr.stateChanged(C.STATUS_CONFIRMED);\n            tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n            return true;\n          }\n        } // ACK to 2XX Response.\n        else {\n            return false;\n          }\n\n        break;\n\n      case SIP.C.CANCEL:\n        tr = ua.transactions.ist[request.via_branch];\n\n        if (tr) {\n          request.reply_sl(200);\n\n          if (tr.state === C.STATUS_PROCEEDING) {\n            return false;\n          } else {\n            return true;\n          }\n        } else {\n          request.reply_sl(481);\n          return true;\n        }\n\n        break;\n\n      default:\n        // Non-INVITE Server Transaction RFC 3261 17.2.2\n        tr = ua.transactions.nist[request.via_branch];\n\n        if (tr) {\n          switch (tr.state) {\n            case C.STATUS_TRYING:\n              break;\n\n            case C.STATUS_PROCEEDING:\n            case C.STATUS_COMPLETED:\n              tr.transport.send(tr.last_response);\n              break;\n          }\n\n          return true;\n        }\n\n        break;\n    }\n  };\n\n  SIP.Transactions = {\n    C: C,\n    checkTransaction: checkTransaction,\n    NonInviteClientTransaction: NonInviteClientTransaction,\n    InviteClientTransaction: InviteClientTransaction,\n    AckClientTransaction: AckClientTransaction,\n    NonInviteServerTransaction: NonInviteServerTransaction,\n    InviteServerTransaction: InviteServerTransaction\n  };\n};","map":null,"metadata":{},"sourceType":"script"}