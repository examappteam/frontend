{"ast":null,"code":"/* globals mozRTCPeerConnection, RTCPeerConnection */\n'use strict';\n\nvar EventTarget = require('../util/eventtarget');\n\nvar FirefoxRTCSessionDescription = require('../rtcsessiondescription/firefox');\n\nvar RTCRtpSenderShim = require('../rtcrtpsender');\n\nvar inherits = require('util').inherits;\n\nvar updateTracksToSSRCs = require('../util/sdp').updateUnifiedPlanTrackIdsToSSRCs;\n\nvar util = require('../util');\n\nvar PeerConnection = typeof RTCPeerConnection !== 'undefined' ? RTCPeerConnection : mozRTCPeerConnection; // NOTE(mroberts): This is a short-lived workaround. Checking the user agent\n// string might not fix every affected Firefox instance, but it should be good\n// enough for this bug.\n\nvar needsWorkaroundForBug1480277 = typeof navigator === 'object' && navigator.userAgent && (navigator.userAgent.match(/Firefox\\/61/) || navigator.userAgent.match(/Firefox\\/62/)); // NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.\n// It provides some functionality not currently present in Firefox, namely the\n// abilities to\n//\n//   1. Call setLocalDescription and setRemoteDescription with new offers in\n//      signalingStates \"have-local-offer\" and \"have-remote-offer\",\n//      respectively.\n//\n//   2. The ability to call createOffer in signalingState \"have-local-offer\".\n//\n// Both of these are implemented using rollbacks to workaround the following\n// bug:\n//\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388\n//\n// We also provide a workaround for a bug where Firefox may change the\n// previously-negotiated DTLS role in an answer, which breaks Chrome:\n//\n//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897\n//\n\nfunction FirefoxRTCPeerConnection(configuration) {\n  if (!(this instanceof FirefoxRTCPeerConnection)) {\n    return new FirefoxRTCPeerConnection(configuration);\n  }\n\n  EventTarget.call(this);\n  util.interceptEvent(this, 'signalingstatechange');\n  /* eslint new-cap:0 */\n\n  var peerConnection = new PeerConnection(configuration);\n  Object.defineProperties(this, {\n    _initiallyNegotiatedDtlsRole: {\n      value: null,\n      writable: true\n    },\n    _isClosed: {\n      value: false,\n      writable: true\n    },\n    _peerConnection: {\n      value: peerConnection\n    },\n    _rollingBack: {\n      value: false,\n      writable: true\n    },\n    _senders: {\n      value: new Map()\n    },\n    _tracksToSSRCs: {\n      value: new Map()\n    },\n    iceGatheringState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;\n      }\n    },\n    localDescription: {\n      enumerable: true,\n      get: function get() {\n        return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);\n      }\n    },\n    signalingState: {\n      enumerable: true,\n      get: function get() {\n        return this._isClosed ? 'closed' : this._peerConnection.signalingState;\n      }\n    }\n  });\n  var self = this;\n  var previousSignalingState;\n  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {\n    if (!self._rollingBack && self.signalingState !== previousSignalingState) {\n      previousSignalingState = self.signalingState; // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is\n      // triggered synchronously in the same tick after\n      // RTCPeerConnection#close() is called. So we mimic Chrome's behavior\n      // by triggering 'signalingstatechange' on the next tick.\n\n      var dispatchEventToSelf = self.dispatchEvent.apply.bind(self.dispatchEvent, self, arguments);\n\n      if (self._isClosed) {\n        setTimeout(dispatchEventToSelf);\n      } else {\n        dispatchEventToSelf();\n      }\n    }\n  });\n  util.proxyProperties(PeerConnection.prototype, this, peerConnection);\n}\n\ninherits(FirefoxRTCPeerConnection, EventTarget); // NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's\n// prototype's \"peerIdentity\" property is accessed. In order to overcome\n// this, we ignore this property while delegating methods.\n// Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815\n\nObject.defineProperty(FirefoxRTCPeerConnection.prototype, 'peerIdentity', {\n  enumerable: true,\n  value: Promise.resolve({\n    idp: '',\n    name: ''\n  })\n}); // NOTE(mmalavalli): Because we are not delegating to the native\n// RTCPeerConnection#removeTrack(), we have to manually maintain a list of added\n// tracks. So we disable the delegation to the native RTCPeerConnection#addTrack()\n// for now.\n\nFirefoxRTCPeerConnection.prototype.addTrack = function addTrack() {\n  var args = [].slice.call(arguments);\n  var track = args[0];\n\n  var sender = this._senders.get(track);\n\n  if (sender && sender.track) {\n    throw new Error('Cannot add MediaStreamTrack [' + track.id + ', ' + track.kind + ']: RTCPeerConnection already has it');\n  }\n\n  sender = getActiveSenders(this._peerConnection).get(track) || this._peerConnection.addTrack.apply(this._peerConnection, args);\n\n  if (needsWorkaroundForBug1480277) {\n    sender.replaceTrack(track);\n  }\n\n  this._senders.set(track, sender);\n\n  return sender;\n};\n\nif (PeerConnection.prototype.addTransceiver) {\n  FirefoxRTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n    var transceiver = this._peerConnection.addTransceiver.apply(this._peerConnection, arguments);\n\n    var sender = transceiver.sender;\n    var track = sender.track;\n\n    if (track && needsWorkaroundForBug1480277) {\n      sender.replaceTrack(track);\n    }\n\n    this._senders.set(track, sender);\n\n    return transceiver;\n  };\n} // NOTE(mmalavalli): RTCPeerConnection#removeTrack() has a bug in the\n// Firefox <--> Chrome interop case, which is mentioned below. So we disable\n// its delegation for now. Also, we maintain only one RTCRtpSender per\n// MediaStreamTrack for our use case, and not worry about multiple RTCRtpSenders\n// due to replaceTrack().\n// Bugzilla: https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n\n\nFirefoxRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n  if (this._isClosed) {\n    throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');\n  }\n\n  var track = sender.track;\n\n  if (!track) {\n    return;\n  }\n\n  sender = this._senders.get(track);\n\n  if (sender && sender.track) {\n    this._senders.set(track, new RTCRtpSenderShim(null));\n  }\n}; // NOTE(mmalavalli): Because we are not delegating to the native\n// RTCPeerConnection#removeTrack(), we have to manually maintain a list of added\n// tracks. So we disable the delegation to the native RTCPeerConnection#getSenders()\n// for now.\n\n\nFirefoxRTCPeerConnection.prototype.getSenders = function getSenders() {\n  return Array.from(this._senders.values());\n};\n\nFirefoxRTCPeerConnection.prototype.createAnswer = function createAnswer() {\n  var args = [].slice.call(arguments);\n  var promise;\n  var self = this;\n  promise = this._peerConnection.createAnswer().then(function createAnswerSucceeded(answer) {\n    saveInitiallyNegotiatedDtlsRole(self, answer);\n    return overwriteWithInitiallyNegotiatedDtlsRole(answer, self._initiallyNegotiatedDtlsRole);\n  });\n  return typeof args[0] === 'function' ? util.legacyPromise(promise, args[0], args[1]) : promise;\n}; // NOTE(mroberts): The WebRTC spec allows you to call createOffer from any\n// signalingState other than \"closed\"; however, Firefox has not yet implemented\n// this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround\n// this by rolling back if we are in state \"have-local-offer\" or\n// \"have-remote-offer\". This is acceptable for our use case because we will\n// apply the newly-created offer almost immediately; however, this may be\n// unacceptable for other use cases.\n\n\nFirefoxRTCPeerConnection.prototype.createOffer = function createOffer() {\n  var args = [].slice.call(arguments);\n  var options = (args.length > 1 ? args[2] : args[0]) || {};\n  var promise;\n  var self = this;\n\n  if (this.signalingState === 'have-local-offer' || this.signalingState === 'have-remote-offer') {\n    var local = this.signalingState === 'have-local-offer';\n    promise = rollback(this, local, function rollbackSucceeded() {\n      return self.createOffer(options);\n    });\n  } else {\n    promise = self._peerConnection.createOffer(options);\n  }\n\n  promise = promise.then(function (offer) {\n    return new FirefoxRTCSessionDescription({\n      type: offer.type,\n      sdp: updateTracksToSSRCs(self._tracksToSSRCs, offer.sdp)\n    });\n  });\n  return args.length > 1 ? util.legacyPromise(promise, args[0], args[1]) : promise;\n}; // NOTE(mroberts): While Firefox will reject the Promise returned by\n// setLocalDescription when called from signalingState \"have-local-offer\" with\n// an answer, it still updates the .localDescription property. We workaround\n// this by explicitly handling this case.\n\n\nFirefoxRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n\n  if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {\n    promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));\n  }\n\n  if (promise) {\n    return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n  }\n\n  return this._peerConnection.setLocalDescription.apply(this._peerConnection, args);\n}; // NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with\n// an offer multiple times in signalingState \"have-remote-offer\"; however,\n// Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).\n// We workaround this by rolling back if we are in state \"have-remote-offer\".\n// This is acceptable for our use case; however, this may be unacceptable for\n// other use cases.\n//\n// While Firefox will reject the Promise returned by setRemoteDescription when\n// called from signalingState \"have-remote-offer\" with an answer, it sill\n// updates the .remoteDescription property. We workaround this by explicitly\n// handling this case.\n\n\nFirefoxRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n  var args = [].slice.call(arguments);\n  var description = args[0];\n  var promise;\n  var self = this;\n\n  if (description && this.signalingState === 'have-remote-offer') {\n    if (description.type === 'answer') {\n      promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));\n    } else if (description.type === 'offer') {\n      promise = rollback(this, false, function rollbackSucceeded() {\n        return self._peerConnection.setRemoteDescription(description);\n      });\n    }\n  }\n\n  if (!promise) {\n    promise = this._peerConnection.setRemoteDescription(description);\n  }\n\n  promise = promise.then(function setRemoteDescriptionSucceeded() {\n    saveInitiallyNegotiatedDtlsRole(self, description, true);\n  });\n  return args.length > 1 ? util.legacyPromise(promise, args[1], args[2]) : promise;\n}; // NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal\n// isClosed slot should immediately be set to true; however, in Firefox it\n// occurs in the next tick. We workaround this by tracking isClosed manually.\n\n\nFirefoxRTCPeerConnection.prototype.close = function close() {\n  if (this.signalingState !== 'closed') {\n    this._isClosed = true;\n\n    this._peerConnection.close();\n  }\n};\n\nutil.delegateMethods(PeerConnection.prototype, FirefoxRTCPeerConnection.prototype, '_peerConnection');\n\nfunction rollback(peerConnection, local, onceRolledBack) {\n  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';\n  peerConnection._rollingBack = true;\n  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({\n    type: 'rollback'\n  })).then(onceRolledBack).then(function onceRolledBackSucceeded(result) {\n    peerConnection._rollingBack = false;\n    return result;\n  }, function rollbackOrOnceRolledBackFailed(error) {\n    peerConnection._rollingBack = false;\n    throw error;\n  });\n}\n/**\n * Extract the initially negotiated DTLS role out of an RTCSessionDescription's\n * sdp property and save it on the FirefoxRTCPeerConnection if and only if\n *\n *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and\n *   2. The description is an answer.\n *\n * @private\n * @param {FirefoxRTCPeerConnection} peerConnection\n * @param {RTCSessionDescription} description\n * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,\n *   e.g. \"active\" instead of \"passive\" and vice versa\n * @returns {undefined}\n */\n\n\nfunction saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {\n  // NOTE(mroberts): JSEP specifies that offers always offer \"actpass\" as the\n  // DTLS role. We need to inspect answers to figure out the negotiated DTLS\n  // role.\n  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {\n    return;\n  }\n\n  var match = description.sdp.match(/a=setup:([a-z]+)/);\n\n  if (!match) {\n    return;\n  }\n\n  var dtlsRole = match[1];\n  peerConnection._initiallyNegotiatedDtlsRole = remote ? {\n    active: 'passive',\n    passive: 'active'\n  }[dtlsRole] : dtlsRole;\n}\n/**\n * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if\n * and only if\n *\n *   1. The description is an answer, and\n *   2. A DTLS role is provided.\n *\n * @private\n * @param {RTCSessionDescription} [description]\n * @param {string} [dtlsRole] - one of \"active\" or \"passive\"\n * @returns {?RTCSessionDescription} description\n */\n\n\nfunction overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {\n  if (description && description.type === 'answer' && dtlsRole) {\n    return new FirefoxRTCSessionDescription({\n      type: description.type,\n      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)\n    });\n  }\n\n  return description;\n}\n/**\n * Gets the active RTCRtpSenders of the RTCPeerConnection.\n * @param peerConnection\n * @returns {Map<MediaStreamTrack, RTCRtpSender>}\n */\n\n\nfunction getActiveSenders(peerConnection) {\n  return new Map(peerConnection.getSenders().filter(function (sender) {\n    return sender.track;\n  }).map(function (sender) {\n    return [sender.track, sender];\n  }));\n}\n\nmodule.exports = FirefoxRTCPeerConnection;","map":null,"metadata":{},"sourceType":"script"}