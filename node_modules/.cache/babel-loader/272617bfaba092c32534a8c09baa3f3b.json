{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar SIP = require('../../sip');\n\nvar SIPJSMediaHandler = function () {\n  function SIPJSMediaHandler(peerConnectionManager, createMessage) {\n    _classCallCheck(this, SIPJSMediaHandler);\n\n    Object.defineProperties(this, {\n      createMessage: {\n        enumerable: true,\n        value: createMessage\n      },\n      peerConnectionManager: {\n        enumerable: true,\n        value: peerConnectionManager\n      }\n    });\n  }\n\n  _createClass(SIPJSMediaHandler, [{\n    key: 'close',\n    value: function close() {\n      this.peerConnectionManager.close();\n    }\n  }, {\n    key: 'getDescription',\n    value: function getDescription() {\n      var connectMessage = Object.assign({\n        /* eslint camelcase:0 */\n        peer_connections: this.peerConnectionManager.getStates()\n      }, this.createMessage());\n      return Promise.resolve({\n        body: JSON.stringify(connectMessage),\n        contentType: 'application/room-signaling+json'\n      });\n    }\n  }, {\n    key: 'hasDescription',\n    value: function hasDescription() {\n      return true;\n    }\n  }, {\n    key: 'hold',\n    value: function hold() {// NOTE(mroberts): We don't use SIP.js's hold functionality.\n    }\n  }, {\n    key: 'isReady',\n    value: function isReady() {\n      // NOTE(mroberts): We don't use SIP.js's isReady functionality.\n      return true;\n    }\n  }, {\n    key: 'isMuted',\n    value: function isMuted() {\n      // NOTE(mroberts): We don't use SIP.js's isMuted functionality.\n      return {\n        audio: false,\n        video: false\n      };\n    }\n  }, {\n    key: 'mute',\n    value: function mute() {// NOTE(mroberts): We don't use SIP.js's mute functionality.\n    }\n  }, {\n    key: 'render',\n    value: function render() {// NOTE(mroberts): We don't use SIP.js's render functionality.\n    }\n  }, {\n    key: 'setDescription',\n    value: function setDescription(message) {\n      var roomState = getRoomState(message);\n\n      if (roomState) {\n        var peerConnectionStates = roomState.peer_connections;\n\n        if (peerConnectionStates) {\n          return this.peerConnectionManager.update(peerConnectionStates);\n        }\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: 'unhold',\n    value: function unhold() {// NOTE(mroberts): We don't use SIP.js's unhold functionality.\n    }\n  }, {\n    key: 'unmute',\n    value: function unmute() {// NOTE(mroberts): We don't use SIP.js's unmute functionality.\n    }\n  }, {\n    key: 'updateIceServers',\n    value: function updateIceServers() {// NOTE(mroberts): We don't use SIP.js's ICE server functionality.\n    }\n  }], [{\n    key: 'defaultFactory',\n    value: function defaultFactory() {// NOTE(mroberts): We don't use SIP.js's defaultFactory functionality.\n    }\n  }]);\n\n  return SIPJSMediaHandler;\n}();\n\nSIPJSMediaHandler.defaultFactory.isSupported = function isSupported() {\n  return SIP.WebRTC.isSupported();\n};\n\nfunction getRoomState(message) {\n  try {\n    return JSON.parse(message.body);\n  } catch (error) {\n    return null;\n  }\n}\n\nmodule.exports = SIPJSMediaHandler;","map":null,"metadata":{},"sourceType":"script"}