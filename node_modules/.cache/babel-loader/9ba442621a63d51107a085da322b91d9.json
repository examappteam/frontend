{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar constants = require('../util/constants');\n\nvar ECS = require('../ecs');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Log = require('../util/log');\n\nvar TimeoutPromise = require('../util/timeoutpromise');\n\nvar util = require('../util');\n\nvar _require = require('../util/twilio-video-errors'),\n    ConfigurationAcquireFailedError = _require.ConfigurationAcquireFailedError;\n\nvar version = require('../../package.json').version;\n\nvar instances = 0;\n/**\n * @typedef {ECS.getConfigurationOptions} NTSIceServerSourceOptions\n * @property {Array<RTCIceServerInit>} [defaultIceServers]\n * @property {number} [defaultTTL]\n * @property {string} [ecsServer]\n * @property {string} [environment=\"prod\"]\n * @property {function(string, ECS.getConfigurationOptions): Promise<object>} [getConfiguration]\n * @property {string} [realm=\"us1\"]\n * @property {Log} [log]\n * @property {number} [timeout]\n */\n\n/**\n * A Network Traversal Service (NTS)-backed implementation of\n * {@link IceServerSource}; useful for getting fresh TURN servers from Twilio.\n * @extends EventEmitter\n * @implements {IceServerSource}\n */\n\nvar NTSIceServerSource = function (_EventEmitter) {\n  _inherits(NTSIceServerSource, _EventEmitter);\n  /**\n   * Construct an {@link NTSIceServerSource}.\n   * @param {string} token - Access Token\n   * @param {NTSIceServerSourceOptions} [options]\n   */\n\n\n  function NTSIceServerSource(token, options) {\n    _classCallCheck(this, NTSIceServerSource);\n\n    var _this = _possibleConstructorReturn(this, (NTSIceServerSource.__proto__ || Object.getPrototypeOf(NTSIceServerSource)).call(this));\n\n    options = Object.assign({\n      abortOnTimeout: false,\n      defaultTTL: constants.ICE_SERVERS_DEFAULT_TTL,\n      environment: constants.DEFAULT_ENVIRONMENT,\n      getConfiguration: ECS.getConfiguration,\n      realm: constants.DEFAULT_REALM,\n      timeout: constants.ICE_SERVERS_TIMEOUT_MS\n    }, options);\n    /* eslint-disable new-cap */\n\n    var defaultIceServers = constants.DEFAULT_ICE_SERVERS(options.environment);\n    var ecsServer = options.ecsServer || constants.ECS_SERVER(options.environment, options.realm);\n    /* eslint-enable new-cap */\n\n    var log = options.log ? options.log.createLog('default', _this) : new Log('default', _this, util.buildLogLevels('off'));\n    Object.defineProperties(_this, {\n      _abortOnTimeout: {\n        value: options.abortOnTimeout\n      },\n      // This Promise represents the current invocation of `poll`. `start` sets it\n      // and `stop` clears it out.\n      _currentPoll: {\n        value: null,\n        writable: true\n      },\n      // In the event that ECS or NTS fail to return ICE servers in a timely\n      // manner, NTSIceServerSource falls back to these servers.\n      _defaultIceServers: {\n        value: defaultIceServers\n      },\n      _defaultTTL: {\n        value: options.defaultTTL\n      },\n      // This is the ECS server NTSIceServerSource communicates with.\n      _ecsServer: {\n        value: ecsServer\n      },\n      _getConfiguration: {\n        value: options.getConfiguration\n      },\n      _instance: {\n        value: ++instances\n      },\n      // This timer ID represents the next invocation of `poll`.\n      _nextPoll: {\n        value: null,\n        writable: true\n      },\n      _log: {\n        value: log\n      },\n      _status: {\n        value: null,\n        writable: true\n      },\n      // This Deferred remains unresolved until `stop` is called. We use it to\n      // short-circuit in `poll`.\n      _stopped: {\n        value: util.defer(),\n        writable: true\n      },\n      // This value configures the amount of time NTSIceServerSource will wait\n      // when fetching ICE servers.\n      _timeout: {\n        value: options.timeout\n      },\n      // This is the Access Token NTSIceServerSource makes requests to ECS with.\n      _token: {\n        value: token\n      }\n    });\n\n    _this._log.info('Created a new NTSIceServerSource');\n\n    _this._log.debug('ECS server:', _this._ecsServer);\n\n    return _this;\n  }\n\n  _createClass(NTSIceServerSource, [{\n    key: 'start',\n    value: function start() {\n      if (!this.isStarted) {\n        this._log.info('Starting');\n\n        this._currentPoll = poll(this);\n      } else {\n        this._log.warn('Already started');\n      }\n\n      return this._currentPoll;\n    }\n  }, {\n    key: 'stop',\n    value: function stop() {\n      if (!this.isStarted) {\n        this._log.warn('Already stopped');\n\n        return;\n      }\n\n      this._log.info('Stopping');\n\n      this._currentPoll = null;\n      clearTimeout(this._nextPoll);\n\n      this._stopped.resolve();\n\n      this._stopped = util.defer();\n\n      this._log.debug('Stopped');\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[NTSIceServerSource #' + this._instance + ']';\n    }\n  }, {\n    key: 'isStarted',\n    get: function get() {\n      return !!this._currentPoll;\n    }\n  }, {\n    key: 'status',\n    get: function get() {\n      return this._status;\n    }\n  }]);\n\n  return NTSIceServerSource;\n}(EventEmitter);\n/**\n * Parse an ECS configuration value, log any warnings, and return a tuple of\n * ICE servers and TTL.\n * @param {NTSIceServerSource} client\n * @param {object} config\n * @returns {Array<Array<RTCIceServerInit>|Number>} iceServersAndTTL\n * @throws {Error}\n */\n\n\nfunction parseECSConfig(client, config) {\n  var nts = util.getOrNull(config, 'video.network_traversal_service');\n\n  if (!nts) {\n    throw new Error('network_traversal_service not available');\n  } else if (nts.warning) {\n    client._log.warn(nts.warning);\n  }\n\n  var iceServers = nts.ice_servers;\n\n  if (!iceServers) {\n    throw new Error('ice_servers not available');\n  }\n\n  client._log.info('Got ICE servers: ' + JSON.stringify(iceServers));\n\n  var ttl = nts.ttl || client._defaultTTL;\n  return [iceServers, ttl];\n}\n/**\n * Get ICE servers and their TTL.\n * @private\n * @param {NTSIceServerSource} nts\n * @returns {Promise<Array<RTCIceServerInit>>} iceServers\n */\n\n\nfunction poll(client) {\n  // We race `getConfiguration` against the `_stopped` Promise so that, when\n  // `stop` is called on the NTSIceServerSource, we can immediately proceed\n  // without waiting on `getConfiguration`.\n  client._log.debug('Getting ECS configuration');\n\n  var options = {\n    configUrl: client._ecsServer + '/v2/Configuration',\n    body: {\n      service: 'video',\n\n      /* eslint-disable camelcase */\n      sdk_version: version\n      /* eslint-enable camelcase */\n\n    }\n  };\n  var alreadyStopped = new Error('Already stopped');\n\n  var config = client._getConfiguration(client._token, options);\n\n  var configWithTimeout = new TimeoutPromise(config, client._timeout);\n  return Promise.race([configWithTimeout, client._stopped.promise]).then(function (config) {\n    if (!config) {\n      throw alreadyStopped;\n    }\n\n    var iceServersAndTTL = parseECSConfig(client, config);\n    client._status = 'success';\n    return iceServersAndTTL;\n  }).catch(function (error) {\n    client._status = 'failure';\n\n    if (!client.isStarted) {\n      throw alreadyStopped;\n    } else if (configWithTimeout.isTimedOut) {\n      if (client._abortOnTimeout) {\n        client._log.warn('Getting ICE servers took too long');\n\n        throw new ConfigurationAcquireFailedError();\n      }\n\n      client._log.warn('Getting ICE servers took too long (using defaults)');\n    } else {\n      // NOTE(mroberts): Stop if we get an Access Token error (2xxxx)\n      if (error.code && Math.floor(error.code / 10000) === 2) {\n        client.stop();\n      }\n\n      client._log.warn('Failed to get ICE servers (using defaults):', error);\n    }\n\n    return [client._defaultIceServers, client._defaultTTL];\n  }).then(function (iceServersAndTTL) {\n    var iceServers = iceServersAndTTL[0];\n    var ttl = iceServersAndTTL[1];\n\n    if (client.isStarted) {\n      client._log.info('Getting ICE servers again in ' + ttl + ' seconds');\n\n      client._nextPoll = setTimeout(function nextPoll() {\n        if (client.isStarted) {\n          client._currentPoll = poll(client);\n        }\n      }, (ttl - constants.ECS_TIMEOUT) * 1000);\n    }\n\n    client._iceServers = iceServers;\n\n    try {\n      client.emit('iceServers', iceServers);\n    } catch (error) {// Do nothing.\n    }\n\n    return iceServers;\n  });\n}\n\nmodule.exports = NTSIceServerSource;","map":null,"metadata":{},"sourceType":"script"}