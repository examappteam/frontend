{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview Utils\n */\n\nmodule.exports = function (SIP, environment) {\n  var Utils;\n  Utils = {\n    Promise: environment.Promise,\n    defer: function defer() {\n      var deferred = {};\n      deferred.promise = new Utils.Promise(function (resolve, reject) {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n      });\n      return deferred;\n    },\n    promisify: function promisify(object, methodName, callbacksFirst) {\n      var oldMethod = object[methodName];\n      return function promisifiedMethod(arg, onSuccess, onFailure) {\n        return new Utils.Promise(function (resolve, reject) {\n          var oldArgs = [arg, resolve, reject];\n\n          if (callbacksFirst) {\n            oldArgs = [resolve, reject, arg];\n          }\n\n          oldMethod.apply(object, oldArgs);\n        }).then(onSuccess, onFailure);\n      };\n    },\n    augment: function augment(object, constructor, args, override) {\n      var idx, proto; // Add public properties from constructor's prototype onto object\n\n      proto = constructor.prototype;\n\n      for (idx in proto) {\n        if (override || object[idx] === undefined) {\n          object[idx] = proto[idx];\n        }\n      } // Construct the object as though it were just created by constructor\n\n\n      constructor.apply(object, args);\n    },\n    optionsOverride: function optionsOverride(options, winner, loser, isDeprecated, logger, defaultValue) {\n      if (isDeprecated && options[loser]) {\n        logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n      }\n\n      if (options[winner] && options[loser]) {\n        logger.warn(winner + ' overriding ' + loser);\n      }\n\n      options[winner] = options[winner] || options[loser] || defaultValue;\n    },\n    str_utf8_length: function str_utf8_length(string) {\n      return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n    },\n    generateFakeSDP: function generateFakeSDP(body) {\n      if (!body) {\n        return;\n      }\n\n      var start = body.indexOf('o=');\n      var end = body.indexOf('\\r\\n', start);\n      return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n    },\n    isFunction: function isFunction(fn) {\n      if (fn !== undefined) {\n        return Object.prototype.toString.call(fn) === '[object Function]';\n      } else {\n        return false;\n      }\n    },\n    isDecimal: function isDecimal(num) {\n      return !isNaN(num) && parseFloat(num) === parseInt(num, 10);\n    },\n    createRandomToken: function createRandomToken(size, base) {\n      var i,\n          r,\n          token = '';\n      base = base || 32;\n\n      for (i = 0; i < size; i++) {\n        r = Math.random() * base | 0;\n        token += r.toString(base);\n      }\n\n      return token;\n    },\n    newTag: function newTag() {\n      return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n    },\n    // http://stackoverflow.com/users/109538/broofa\n    newUUID: function newUUID() {\n      var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n            v = c === 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n      return UUID;\n    },\n    hostType: function hostType(host) {\n      if (!host) {\n        return;\n      } else {\n        host = SIP.Grammar.parse(host, 'host');\n\n        if (host !== -1) {\n          return host.host_type;\n        }\n      }\n    },\n\n    /**\n    * Normalize SIP URI.\n    * NOTE: It does not allow a SIP URI without username.\n    * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n    * Detects the domain part (if given) and properly hex-escapes the user portion.\n    * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n    * @private\n    * @param {String} target\n    * @param {String} [domain]\n    */\n    normalizeTarget: function normalizeTarget(target, domain) {\n      var uri, target_array, target_user, target_domain; // If no target is given then raise an error.\n\n      if (!target) {\n        return; // If a SIP.URI instance is given then return it.\n      } else if (target instanceof SIP.URI) {\n        return target; // If a string is given split it by '@':\n        // - Last fragment is the desired domain.\n        // - Otherwise append the given domain argument.\n      } else if (typeof target === 'string') {\n        target_array = target.split('@');\n\n        switch (target_array.length) {\n          case 1:\n            if (!domain) {\n              return;\n            }\n\n            target_user = target;\n            target_domain = domain;\n            break;\n\n          case 2:\n            target_user = target_array[0];\n            target_domain = target_array[1];\n            break;\n\n          default:\n            target_user = target_array.slice(0, target_array.length - 1).join('@');\n            target_domain = target_array[target_array.length - 1];\n        } // Remove the URI scheme (if present).\n\n\n        target_user = target_user.replace(/^(sips?|tel):/i, ''); // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n\n        if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n          target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n        } // Build the complete SIP URI.\n\n\n        target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain; // Finally parse the resulting URI.\n\n        if (uri = SIP.URI.parse(target)) {\n          return uri;\n        } else {\n          return;\n        }\n      } else {\n        return;\n      }\n    },\n\n    /**\n    * Hex-escape a SIP URI user.\n    * @private\n    * @param {String} user\n    */\n    escapeUser: function escapeUser(user) {\n      // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n      return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n    },\n    headerize: function headerize(string) {\n      var exceptions = {\n        'Call-Id': 'Call-ID',\n        'Cseq': 'CSeq',\n        'Min-Se': 'Min-SE',\n        'Rack': 'RAck',\n        'Rseq': 'RSeq',\n        'Www-Authenticate': 'WWW-Authenticate'\n      },\n          name = string.toLowerCase().replace(/_/g, '-').split('-'),\n          hname = '',\n          parts = name.length,\n          part;\n\n      for (part = 0; part < parts; part++) {\n        if (part !== 0) {\n          hname += '-';\n        }\n\n        hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n      }\n\n      if (exceptions[hname]) {\n        hname = exceptions[hname];\n      }\n\n      return hname;\n    },\n    sipErrorCause: function sipErrorCause(status_code) {\n      var cause;\n\n      for (cause in SIP.C.SIP_ERROR_CAUSES) {\n        if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n          return SIP.C.causes[cause];\n        }\n      }\n\n      return SIP.C.causes.SIP_FAILURE_CODE;\n    },\n    getReasonPhrase: function getReasonPhrase(code, specific) {\n      return specific || SIP.C.REASON_PHRASE[code] || '';\n    },\n    getReasonHeaderValue: function getReasonHeaderValue(code, reason) {\n      reason = SIP.Utils.getReasonPhrase(code, reason);\n      return 'SIP ;cause=' + code + ' ;text=\"' + reason + '\"';\n    },\n    getCancelReason: function getCancelReason(code, reason) {\n      if (code && code < 200 || code > 699) {\n        throw new TypeError('Invalid status_code: ' + code);\n      } else if (code) {\n        return SIP.Utils.getReasonHeaderValue(code, reason);\n      }\n    },\n    buildStatusLine: function buildStatusLine(code, reason) {\n      code = code || null;\n      reason = reason || null; // Validate code and reason values\n\n      if (!code || code < 100 || code > 699) {\n        throw new TypeError('Invalid status_code: ' + code);\n      } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n        throw new TypeError('Invalid reason_phrase: ' + reason);\n      }\n\n      reason = Utils.getReasonPhrase(code, reason);\n      return 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n    },\n\n    /**\n    * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n    * @private\n    */\n    getRandomTestNetIP: function getRandomTestNetIP() {\n      function getOctet(from, to) {\n        return Math.floor(Math.random() * (to - from + 1) + from);\n      }\n\n      return '192.0.2.' + getOctet(1, 254);\n    },\n    // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info\n    calculateMD5: function calculateMD5(string) {\n      function RotateLeft(lValue, iShiftBits) {\n        return lValue << iShiftBits | lValue >>> 32 - iShiftBits;\n      }\n\n      function AddUnsigned(lX, lY) {\n        var lX4, lY4, lX8, lY8, lResult;\n        lX8 = lX & 0x80000000;\n        lY8 = lY & 0x80000000;\n        lX4 = lX & 0x40000000;\n        lY4 = lY & 0x40000000;\n        lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\n\n        if (lX4 & lY4) {\n          return lResult ^ 0x80000000 ^ lX8 ^ lY8;\n        }\n\n        if (lX4 | lY4) {\n          if (lResult & 0x40000000) {\n            return lResult ^ 0xC0000000 ^ lX8 ^ lY8;\n          } else {\n            return lResult ^ 0x40000000 ^ lX8 ^ lY8;\n          }\n        } else {\n          return lResult ^ lX8 ^ lY8;\n        }\n      }\n\n      function F(x, y, z) {\n        return x & y | ~x & z;\n      }\n\n      function G(x, y, z) {\n        return x & z | y & ~z;\n      }\n\n      function H(x, y, z) {\n        return x ^ y ^ z;\n      }\n\n      function I(x, y, z) {\n        return y ^ (x | ~z);\n      }\n\n      function FF(a, b, c, d, x, s, ac) {\n        a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n        return AddUnsigned(RotateLeft(a, s), b);\n      }\n\n      function GG(a, b, c, d, x, s, ac) {\n        a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n        return AddUnsigned(RotateLeft(a, s), b);\n      }\n\n      function HH(a, b, c, d, x, s, ac) {\n        a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n        return AddUnsigned(RotateLeft(a, s), b);\n      }\n\n      function II(a, b, c, d, x, s, ac) {\n        a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n        return AddUnsigned(RotateLeft(a, s), b);\n      }\n\n      function ConvertToWordArray(string) {\n        var lWordCount;\n        var lMessageLength = string.length;\n        var lNumberOfWords_temp1 = lMessageLength + 8;\n        var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;\n        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\n        var lWordArray = Array(lNumberOfWords - 1);\n        var lBytePosition = 0;\n        var lByteCount = 0;\n\n        while (lByteCount < lMessageLength) {\n          lWordCount = (lByteCount - lByteCount % 4) / 4;\n          lBytePosition = lByteCount % 4 * 8;\n          lWordArray[lWordCount] = lWordArray[lWordCount] | string.charCodeAt(lByteCount) << lBytePosition;\n          lByteCount++;\n        }\n\n        lWordCount = (lByteCount - lByteCount % 4) / 4;\n        lBytePosition = lByteCount % 4 * 8;\n        lWordArray[lWordCount] = lWordArray[lWordCount] | 0x80 << lBytePosition;\n        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n        return lWordArray;\n      }\n\n      function WordToHex(lValue) {\n        var WordToHexValue = \"\",\n            WordToHexValue_temp = \"\",\n            lByte,\n            lCount;\n\n        for (lCount = 0; lCount <= 3; lCount++) {\n          lByte = lValue >>> lCount * 8 & 255;\n          WordToHexValue_temp = \"0\" + lByte.toString(16);\n          WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);\n        }\n\n        return WordToHexValue;\n      }\n\n      function Utf8Encode(string) {\n        string = string.replace(/\\r\\n/g, \"\\n\");\n        var utftext = \"\";\n\n        for (var n = 0; n < string.length; n++) {\n          var c = string.charCodeAt(n);\n\n          if (c < 128) {\n            utftext += String.fromCharCode(c);\n          } else if (c > 127 && c < 2048) {\n            utftext += String.fromCharCode(c >> 6 | 192);\n            utftext += String.fromCharCode(c & 63 | 128);\n          } else {\n            utftext += String.fromCharCode(c >> 12 | 224);\n            utftext += String.fromCharCode(c >> 6 & 63 | 128);\n            utftext += String.fromCharCode(c & 63 | 128);\n          }\n        }\n\n        return utftext;\n      }\n\n      var x = [];\n      var k, AA, BB, CC, DD, a, b, c, d;\n      var S11 = 7,\n          S12 = 12,\n          S13 = 17,\n          S14 = 22;\n      var S21 = 5,\n          S22 = 9,\n          S23 = 14,\n          S24 = 20;\n      var S31 = 4,\n          S32 = 11,\n          S33 = 16,\n          S34 = 23;\n      var S41 = 6,\n          S42 = 10,\n          S43 = 15,\n          S44 = 21;\n      string = Utf8Encode(string);\n      x = ConvertToWordArray(string);\n      a = 0x67452301;\n      b = 0xEFCDAB89;\n      c = 0x98BADCFE;\n      d = 0x10325476;\n\n      for (k = 0; k < x.length; k += 16) {\n        AA = a;\n        BB = b;\n        CC = c;\n        DD = d;\n        a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);\n        d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);\n        c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);\n        b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);\n        a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);\n        d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);\n        c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);\n        b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);\n        a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);\n        d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);\n        c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);\n        b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);\n        a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);\n        d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);\n        c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);\n        b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);\n        a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);\n        d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);\n        c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);\n        b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);\n        a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);\n        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);\n        c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);\n        b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);\n        a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);\n        d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);\n        c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);\n        b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);\n        a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);\n        d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);\n        c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);\n        b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);\n        a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);\n        d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);\n        c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);\n        b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);\n        a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);\n        d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);\n        c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);\n        b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);\n        a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);\n        d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);\n        c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);\n        b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);\n        a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);\n        d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);\n        c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);\n        b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);\n        a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);\n        d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);\n        c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);\n        b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);\n        a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);\n        d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);\n        c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);\n        b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);\n        a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);\n        d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);\n        c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);\n        b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);\n        a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);\n        d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);\n        c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);\n        b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);\n        a = AddUnsigned(a, AA);\n        b = AddUnsigned(b, BB);\n        c = AddUnsigned(c, CC);\n        d = AddUnsigned(d, DD);\n      }\n\n      var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);\n      return temp.toLowerCase();\n    }\n  };\n  SIP.Utils = Utils;\n};","map":null,"metadata":{},"sourceType":"script"}