{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n */\n\n/**\n * @augments SIP\n * @class Class creating a SIP Subscription.\n */\n\nmodule.exports = function (SIP) {\n  SIP.Subscription = function (ua, target, event, options) {\n    options = Object.create(options || Object.prototype);\n    this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();\n    this.id = null;\n    this.state = 'init';\n\n    if (!event) {\n      throw new TypeError('Event necessary to create a subscription.');\n    } else {\n      //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n      //The check may need to/should probably occur on the other side,\n      this.event = event;\n    }\n\n    if (typeof options.expires !== 'number') {\n      ua.logger.warn('expires must be a number. Using default of 3600.');\n      this.expires = 3600;\n    } else {\n      this.expires = options.expires;\n    }\n\n    options.extraHeaders.push('Event: ' + this.event);\n    options.extraHeaders.push('Expires: ' + this.expires);\n\n    if (options.body) {\n      this.body = options.body;\n    }\n\n    this.contact = ua.contact.toString();\n    options.extraHeaders.push('Contact: ' + this.contact);\n    options.extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n    SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n    this.logger = ua.getLogger('sip.subscription');\n    this.dialog = null;\n    this.timers = {\n      N: null,\n      sub_duration: null\n    };\n    this.errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];\n  };\n\n  SIP.Subscription.prototype = {\n    subscribe: function subscribe() {\n      var sub = this; //these states point to an existing subscription, no subscribe is necessary\n\n      if (this.state === 'active') {\n        this.refresh();\n        return this;\n      } else if (this.state === 'notify_wait') {\n        return this;\n      }\n\n      SIP.Timers.clearTimeout(this.timers.sub_duration);\n      SIP.Timers.clearTimeout(this.timers.N);\n      this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n      this.send();\n      this.state = 'notify_wait';\n      return this;\n    },\n    refresh: function refresh() {\n      if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {\n        return;\n      }\n\n      this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {\n        extraHeaders: this.extraHeaders,\n        body: this.body\n      });\n    },\n    receiveResponse: function receiveResponse(response) {\n      var expires,\n          sub = this,\n          cause = SIP.Utils.getReasonPhrase(response.status_code);\n\n      if (this.state === 'notify_wait' && response.status_code >= 300 || this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1) {\n        this.failed(response, null);\n      } else if (/^2[0-9]{2}$/.test(response.status_code)) {\n        expires = response.getHeader('Expires');\n        SIP.Timers.clearTimeout(this.timers.N);\n\n        if (this.createConfirmedDialog(response, 'UAC')) {\n          this.id = this.dialog.id.toString();\n          this.ua.subscriptions[this.id] = this;\n          this.emit('accepted', response, cause); // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n        }\n\n        if (expires && expires <= this.expires) {\n          // Preserve new expires value for subsequent requests\n          this.expires = expires;\n          this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);\n        } else {\n          if (!expires) {\n            this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n            this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n          } else {\n            this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n            this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n          }\n        }\n      } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx\n\n    },\n    unsubscribe: function unsubscribe() {\n      var extraHeaders = [],\n          sub = this;\n      this.state = 'terminated';\n      extraHeaders.push('Event: ' + this.event);\n      extraHeaders.push('Expires: 0');\n      extraHeaders.push('Contact: ' + this.contact);\n      extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString()); //makes sure expires isn't set, and other typical resubscribe behavior\n\n      this.receiveResponse = function () {};\n\n      this.dialog.sendRequest(this, this.method, {\n        extraHeaders: extraHeaders,\n        body: this.body\n      });\n      SIP.Timers.clearTimeout(this.timers.sub_duration);\n      SIP.Timers.clearTimeout(this.timers.N);\n      this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n    },\n\n    /**\n    * @private\n    */\n    timer_fire: function timer_fire() {\n      if (this.state === 'terminated') {\n        this.terminateDialog();\n        SIP.Timers.clearTimeout(this.timers.N);\n        SIP.Timers.clearTimeout(this.timers.sub_duration);\n        delete this.ua.subscriptions[this.id];\n      } else if (this.state === 'pending' || this.state === 'notify_wait') {\n        this.close();\n      } else {\n        this.refresh();\n      }\n    },\n\n    /**\n    * @private\n    */\n    close: function close() {\n      if (this.state !== 'notify_wait' && this.state !== 'terminated') {\n        this.unsubscribe();\n      }\n    },\n\n    /**\n    * @private\n    */\n    createConfirmedDialog: function createConfirmedDialog(message, type) {\n      var dialog;\n      this.terminateDialog();\n      dialog = new SIP.Dialog(this, message, type);\n\n      if (!dialog.error) {\n        this.dialog = dialog;\n        return true;\n      } // Dialog not created due to an error\n      else {\n          return false;\n        }\n    },\n\n    /**\n    * @private\n    */\n    terminateDialog: function terminateDialog() {\n      if (this.dialog) {\n        delete this.ua.subscriptions[this.id];\n        this.dialog.terminate();\n        delete this.dialog;\n      }\n    },\n\n    /**\n    * @private\n    */\n    receiveRequest: function receiveRequest(request) {\n      var sub_state,\n          sub = this;\n\n      function setExpiresTimeout() {\n        if (sub_state.expires) {\n          SIP.Timers.clearTimeout(sub.timers.sub_duration);\n          sub_state.expires = Math.min(sub.expires, Math.max(sub_state.expires, 0));\n          sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), sub_state.expires * 900);\n        }\n      }\n\n      if (!this.matchEvent(request)) {\n        //checks event and subscription_state headers\n        request.reply(489);\n        return;\n      }\n\n      sub_state = request.parseHeader('Subscription-State');\n      request.reply(200, SIP.C.REASON_200);\n      SIP.Timers.clearTimeout(this.timers.N);\n      this.emit('notify', {\n        request: request\n      }); // if we've set state to terminated, no further processing should take place\n      // and we are only interested in cleaning up after the appropriate NOTIFY\n\n      if (this.state === 'terminated') {\n        if (sub_state.state === 'terminated') {\n          this.terminateDialog();\n          SIP.Timers.clearTimeout(this.timers.N);\n          SIP.Timers.clearTimeout(this.timers.sub_duration);\n          delete this.ua.subscriptions[this.id];\n        }\n\n        return;\n      }\n\n      switch (sub_state.state) {\n        case 'active':\n          this.state = 'active';\n          setExpiresTimeout();\n          break;\n\n        case 'pending':\n          if (this.state === 'notify_wait') {\n            setExpiresTimeout();\n          }\n\n          this.state = 'pending';\n          break;\n\n        case 'terminated':\n          SIP.Timers.clearTimeout(this.timers.sub_duration);\n\n          if (sub_state.reason) {\n            this.logger.log('terminating subscription with reason ' + sub_state.reason);\n\n            switch (sub_state.reason) {\n              case 'deactivated':\n              case 'timeout':\n                this.subscribe();\n                return;\n\n              case 'probation':\n              case 'giveup':\n                if (sub_state.params && sub_state.params['retry-after']) {\n                  this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n                } else {\n                  this.subscribe();\n                }\n\n                return;\n\n              case 'rejected':\n              case 'noresource':\n              case 'invariant':\n                break;\n            }\n          }\n\n          this.close();\n          break;\n      }\n    },\n    failed: function failed(response, cause) {\n      this.close();\n      this.emit('failed', response, cause);\n      return this;\n    },\n    onDialogError: function onDialogError(response) {\n      this.failed(response, SIP.C.causes.DIALOG_ERROR);\n    },\n\n    /**\n    * @private\n    */\n    matchEvent: function matchEvent(request) {\n      var event; // Check mandatory header Event\n\n      if (!request.hasHeader('Event')) {\n        this.logger.warn('missing Event header');\n        return false;\n      } // Check mandatory header Subscription-State\n\n\n      if (!request.hasHeader('Subscription-State')) {\n        this.logger.warn('missing Subscription-State header');\n        return false;\n      } // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n\n\n      event = request.parseHeader('event').event;\n\n      if (this.event !== event) {\n        this.logger.warn('event match failed');\n        request.reply(481, 'Event Match Failed');\n        return false;\n      } else {\n        return true;\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}