{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview Transport\n */\n\n/**\n * @augments SIP\n * @class Transport\n * @param {SIP.UA} ua\n * @param {Object} server ws_server Object\n */\n\nmodule.exports = function (SIP, WebSocket) {\n  var Transport,\n      C = {\n    // Transport status codes\n    STATUS_READY: 0,\n    STATUS_DISCONNECTED: 1,\n    STATUS_ERROR: 2\n  };\n  /**\n   * Compute an amount of time in seconds to wait before sending another\n   * keep-alive.\n   * @returns {Number}\n   */\n\n  function computeKeepAliveTimeout(upperBound) {\n    var lowerBound = upperBound * 0.8;\n    return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n  }\n\n  Transport = function Transport(ua, server) {\n    this.logger = ua.getLogger('sip.transport');\n    this.ua = ua;\n    this.ws = null;\n    this.server = server;\n    this.reconnection_attempts = 0;\n    this.closed = false;\n    this.connected = false;\n    this.reconnectTimer = null;\n    this.lastTransportError = {};\n    this.keepAliveInterval = ua.configuration.keepAliveInterval;\n    this.keepAliveTimeout = null;\n    this.keepAliveTimer = null;\n    this.ua.transport = this; // Connect\n\n    this.connect();\n  };\n\n  Transport.prototype = {\n    /**\n     * Send a message.\n     * @param {SIP.OutgoingRequest|String} msg\n     * @returns {Boolean}\n     */\n    send: function send(msg) {\n      var message = msg.toString();\n\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        if (this.ua.configuration.traceSip === true) {\n          this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n        }\n\n        this.ws.send(message);\n        return true;\n      } else {\n        this.logger.warn('unable to send message, WebSocket is not open');\n        return false;\n      }\n    },\n\n    /**\n     * Send a keep-alive (a double-CRLF sequence).\n     * @private\n     * @returns {Boolean}\n     */\n    sendKeepAlive: function sendKeepAlive() {\n      if (this.keepAliveTimeout) {\n        return;\n      }\n\n      this.keepAliveTimeout = SIP.Timers.setTimeout(function () {\n        this.ua.emit('keepAliveTimeout');\n      }.bind(this), 10000);\n      return this.send('\\r\\n\\r\\n');\n    },\n\n    /**\n     * Start sending keep-alives.\n     * @private\n     */\n    startSendingKeepAlives: function startSendingKeepAlives() {\n      if (this.keepAliveInterval && !this.keepAliveTimer) {\n        this.keepAliveTimer = SIP.Timers.setTimeout(function () {\n          this.sendKeepAlive();\n          this.keepAliveTimer = null;\n          this.startSendingKeepAlives();\n        }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));\n      }\n    },\n\n    /**\n     * Stop sending keep-alives.\n     * @private\n     */\n    stopSendingKeepAlives: function stopSendingKeepAlives() {\n      SIP.Timers.clearTimeout(this.keepAliveTimer);\n      SIP.Timers.clearTimeout(this.keepAliveTimeout);\n      this.keepAliveTimer = null;\n      this.keepAliveTimeout = null;\n    },\n\n    /**\n    * Disconnect socket.\n    */\n    disconnect: function disconnect() {\n      if (this.ws) {\n        // Clear reconnectTimer\n        SIP.Timers.clearTimeout(this.reconnectTimer);\n        this.stopSendingKeepAlives();\n        this.closed = true;\n        this.logger.log('closing WebSocket ' + this.server.ws_uri);\n        this.ws.close();\n      }\n\n      if (this.reconnectTimer !== null) {\n        SIP.Timers.clearTimeout(this.reconnectTimer);\n        this.reconnectTimer = null;\n        this.ua.emit('disconnected', {\n          transport: this,\n          code: this.lastTransportError.code,\n          reason: this.lastTransportError.reason\n        });\n      }\n    },\n\n    /**\n    * Connect socket.\n    */\n    connect: function connect() {\n      var transport = this;\n\n      if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n        this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');\n        return false;\n      }\n\n      if (this.ws) {\n        this.ws.close();\n      }\n\n      this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n      this.ua.onTransportConnecting(this, this.reconnection_attempts === 0 ? 1 : this.reconnection_attempts);\n\n      try {\n        this.ws = new WebSocket(this.server.ws_uri, 'sip');\n      } catch (e) {\n        this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);\n      }\n\n      this.ws.binaryType = 'arraybuffer';\n\n      this.ws.onopen = function () {\n        transport.onOpen();\n      };\n\n      this.ws.onclose = function (e) {\n        transport.onClose(e);\n      };\n\n      this.ws.onmessage = function (e) {\n        transport.onMessage(e);\n      };\n\n      this.ws.onerror = function (e) {\n        transport.onError(e);\n      };\n    },\n    // Transport Event Handlers\n\n    /**\n    * @event\n    * @param {event} e\n    */\n    onOpen: function onOpen() {\n      this.connected = true;\n      this.logger.log('WebSocket ' + this.server.ws_uri + ' connected'); // Clear reconnectTimer since we are not disconnected\n\n      if (this.reconnectTimer !== null) {\n        SIP.Timers.clearTimeout(this.reconnectTimer);\n        this.reconnectTimer = null;\n      } // Reset reconnection_attempts\n\n\n      this.reconnection_attempts = 0; // Disable closed\n\n      this.closed = false; // Trigger onTransportConnected callback\n\n      this.ua.onTransportConnected(this); // Start sending keep-alives\n\n      this.startSendingKeepAlives();\n    },\n\n    /**\n    * @event\n    * @param {event} e\n    */\n    onClose: function onClose(e) {\n      var connected_before = this.connected;\n      this.lastTransportError.code = e.code;\n      this.lastTransportError.reason = e.reason;\n      this.stopSendingKeepAlives();\n\n      if (this.reconnection_attempts > 0) {\n        this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason ? '| reason: ' + e.reason : '') + ')');\n        this.reconnect();\n      } else {\n        this.connected = false;\n        this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason ? '| reason: ' + e.reason : '') + ')');\n\n        if (e.wasClean === false) {\n          this.logger.warn('WebSocket abrupt disconnection');\n        } // Transport was connected\n\n\n        if (connected_before === true) {\n          this.ua.onTransportClosed(this); // Check whether the user requested to close.\n\n          if (!this.closed) {\n            this.reconnect();\n          } else {\n            this.ua.emit('disconnected', {\n              transport: this,\n              code: this.lastTransportError.code,\n              reason: this.lastTransportError.reason\n            });\n          }\n        } else {\n          // This is the first connection attempt\n          //Network error\n          this.ua.onTransportError(this);\n        }\n      }\n    },\n\n    /**\n    * @event\n    * @param {event} e\n    */\n    onMessage: function onMessage(e) {\n      var message,\n          transaction,\n          data = e.data; // CRLF Keep Alive response from server. Ignore it.\n\n      if (data === '\\r\\n') {\n        SIP.Timers.clearTimeout(this.keepAliveTimeout);\n        this.keepAliveTimeout = null;\n\n        if (this.ua.configuration.traceSip === true) {\n          this.logger.log('received WebSocket message with CRLF Keep Alive response');\n        }\n\n        return;\n      } // WebSocket binary message.\n      else if (typeof data !== 'string') {\n          try {\n            data = String.fromCharCode.apply(null, new Uint8Array(data));\n          } catch (evt) {\n            this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n            return;\n          }\n\n          if (this.ua.configuration.traceSip === true) {\n            this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n          }\n        } // WebSocket text message.\n        else {\n            if (this.ua.configuration.traceSip === true) {\n              this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n            }\n          }\n\n      message = SIP.Parser.parseMessage(data, this.ua);\n\n      if (!message) {\n        return;\n      }\n\n      if (this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n        return;\n      } // Do some sanity check\n\n\n      if (SIP.sanityCheck(message, this.ua, this)) {\n        if (message instanceof SIP.IncomingRequest) {\n          message.transport = this;\n          this.ua.receiveRequest(message);\n        } else if (message instanceof SIP.IncomingResponse) {\n          /* Unike stated in 18.1.2, if a response does not match\n          * any transaction, it is discarded here and no passed to the core\n          * in order to be discarded there.\n          */\n          switch (message.method) {\n            case SIP.C.INVITE:\n              transaction = this.ua.transactions.ict[message.via_branch];\n\n              if (transaction) {\n                transaction.receiveResponse(message);\n              }\n\n              break;\n\n            case SIP.C.ACK:\n              // Just in case ;-)\n              break;\n\n            default:\n              transaction = this.ua.transactions.nict[message.via_branch];\n\n              if (transaction) {\n                transaction.receiveResponse(message);\n              }\n\n              break;\n          }\n        }\n      }\n    },\n\n    /**\n    * @event\n    * @param {event} e\n    */\n    onError: function onError(e) {\n      this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));\n    },\n\n    /**\n    * Reconnection attempt logic.\n    * @private\n    */\n    reconnect: function reconnect() {\n      var transport = this;\n      this.reconnection_attempts += 1;\n\n      if (this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {\n        this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n        this.ua.onTransportError(this);\n      } else if (this.reconnection_attempts === 1) {\n        this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');\n        transport.connect();\n      } else {\n        this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');\n        this.reconnectTimer = SIP.Timers.setTimeout(function () {\n          transport.connect();\n          transport.reconnectTimer = null;\n        }, this.ua.configuration.wsServerReconnectionTimeout * 1000);\n      }\n    }\n  };\n  Transport.C = C;\n  return Transport;\n};","map":null,"metadata":{},"sourceType":"script"}