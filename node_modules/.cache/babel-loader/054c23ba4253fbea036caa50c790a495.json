{"ast":null,"code":"\"use strict\";\n/**\n * @augments SIP\n * @class Class creating a SIP User Agent.\n * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]\n *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.\n *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.\n *\n * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n */\n\nmodule.exports = function (SIP, environment) {\n  var UA,\n      C = {\n    // UA status codes\n    STATUS_INIT: 0,\n    STATUS_STARTING: 1,\n    STATUS_READY: 2,\n    STATUS_USER_CLOSED: 3,\n    STATUS_NOT_READY: 4,\n    // UA error codes\n    CONFIGURATION_ERROR: 1,\n    NETWORK_ERROR: 2,\n    ALLOWED_METHODS: ['ACK', 'CANCEL', 'INVITE', 'MESSAGE', 'BYE', 'OPTIONS', 'INFO', 'NOTIFY', 'REFER'],\n    ACCEPTED_BODY_TYPES: ['application/sdp', 'application/dtmf-relay'],\n    MAX_FORWARDS: 70,\n    TAG_LENGTH: 10\n  };\n\n  UA = function UA(configuration) {\n    var self = this; // Helper function for forwarding events\n\n    function selfEmit(type) {\n      //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n      return self.emit.bind(self, type);\n    } // Set Accepted Body Types\n\n\n    C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n    this.log = new SIP.LoggerFactory();\n    this.logger = this.getLogger('sip.ua');\n    this.cache = {\n      credentials: {}\n    };\n    this.configuration = {};\n    this.dialogs = {}; //User actions outside any session/dialog (MESSAGE)\n\n    this.applicants = {};\n    this.data = {};\n    this.sessions = {};\n    this.subscriptions = {};\n    this.transport = null;\n    this.contact = null;\n    this.status = C.STATUS_INIT;\n    this.error = null;\n    this.transactions = {\n      nist: {},\n      nict: {},\n      ist: {},\n      ict: {}\n    };\n    this.transportRecoverAttempts = 0;\n    this.transportRecoveryTimer = null;\n    Object.defineProperties(this, {\n      transactionsCount: {\n        get: function get() {\n          var type,\n              transactions = ['nist', 'nict', 'ist', 'ict'],\n              count = 0;\n\n          for (type in transactions) {\n            count += Object.keys(this.transactions[transactions[type]]).length;\n          }\n\n          return count;\n        }\n      },\n      nictTransactionsCount: {\n        get: function get() {\n          return Object.keys(this.transactions['nict']).length;\n        }\n      },\n      nistTransactionsCount: {\n        get: function get() {\n          return Object.keys(this.transactions['nist']).length;\n        }\n      },\n      ictTransactionsCount: {\n        get: function get() {\n          return Object.keys(this.transactions['ict']).length;\n        }\n      },\n      istTransactionsCount: {\n        get: function get() {\n          return Object.keys(this.transactions['ist']).length;\n        }\n      }\n    });\n    /**\n     * Load configuration\n     *\n     * @throws {SIP.Exceptions.ConfigurationError}\n     * @throws {TypeError}\n     */\n\n    if (configuration === undefined) {\n      configuration = {};\n    } else if (typeof configuration === 'string' || configuration instanceof String) {\n      configuration = {\n        uri: configuration\n      };\n    } // Apply log configuration if present\n\n\n    if (configuration.log) {\n      if (configuration.log.hasOwnProperty('builtinEnabled')) {\n        this.log.builtinEnabled = configuration.log.builtinEnabled;\n      }\n\n      if (configuration.log.hasOwnProperty('level')) {\n        this.log.level = configuration.log.level;\n      }\n\n      if (configuration.log.hasOwnProperty('connector')) {\n        this.log.connector = configuration.log.connector;\n      }\n    }\n\n    try {\n      this.loadConfig(configuration);\n    } catch (e) {\n      this.status = C.STATUS_NOT_READY;\n      this.error = C.CONFIGURATION_ERROR;\n      throw e;\n    } // Initialize registerContext\n\n\n    this.registerContext = new SIP.RegisterContext(this);\n    this.registerContext.on('failed', selfEmit('registrationFailed'));\n    this.registerContext.on('registered', selfEmit('registered'));\n    this.registerContext.on('unregistered', selfEmit('unregistered'));\n\n    if (this.configuration.autostart) {\n      this.start();\n    }\n\n    if (typeof environment.addEventListener === 'function') {\n      // Google Chrome Packaged Apps don't allow 'unload' listeners:\n      // unload is not available in packaged apps\n      if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {\n        environment.addEventListener('unload', this.stop.bind(this));\n      }\n    }\n  };\n\n  UA.prototype = Object.create(SIP.EventEmitter.prototype); //=================\n  //  High Level API\n  //=================\n\n  UA.prototype.register = function (options) {\n    this.configuration.register = true;\n    this.registerContext.register(options);\n    return this;\n  };\n  /**\n   * Unregister.\n   *\n   * @param {Boolean} [all] unregister all user bindings.\n   *\n   */\n\n\n  UA.prototype.unregister = function (options) {\n    this.configuration.register = false;\n    var context = this.registerContext;\n    this.afterConnected(context.unregister.bind(context, options));\n    return this;\n  };\n\n  UA.prototype.isRegistered = function () {\n    return this.registerContext.registered;\n  };\n  /**\n   * Connection state.\n   * @param {Boolean}\n   */\n\n\n  UA.prototype.isConnected = function () {\n    return this.transport ? this.transport.connected : false;\n  };\n\n  UA.prototype.afterConnected = function afterConnected(callback) {\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.once('connected', callback);\n    }\n  };\n  /**\n   * Make an outgoing call.\n   *\n   * @param {String} target\n   * @param {Object} views\n   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n   *\n   * @throws {TypeError}\n   *\n   */\n\n\n  UA.prototype.invite = function (target, options) {\n    var context = new SIP.InviteClientContext(this, target, options);\n    this.afterConnected(context.invite.bind(context));\n    return context;\n  };\n\n  UA.prototype.subscribe = function (target, event, options) {\n    var sub = new SIP.Subscription(this, target, event, options);\n    this.afterConnected(sub.subscribe.bind(sub));\n    return sub;\n  };\n  /**\n   * Send a message.\n   *\n   * @param {String} target\n   * @param {String} body\n   * @param {Object} [options]\n   *\n   * @throws {TypeError}\n   *\n   */\n\n\n  UA.prototype.message = function (target, body, options) {\n    if (body === undefined) {\n      throw new TypeError('Not enough arguments');\n    } // There is no Message module, so it is okay that the UA handles defaults here.\n\n\n    options = Object.create(options || Object.prototype);\n    options.contentType || (options.contentType = 'text/plain');\n    options.body = body;\n    return this.request(SIP.C.MESSAGE, target, options);\n  };\n\n  UA.prototype.request = function (method, target, options) {\n    var req = new SIP.ClientContext(this, method, target, options);\n    this.afterConnected(req.send.bind(req));\n    return req;\n  };\n  /**\n   * Gracefully close.\n   *\n   */\n\n\n  UA.prototype.stop = function () {\n    var session,\n        subscription,\n        applicant,\n        ua = this;\n\n    function transactionsListener() {\n      if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n        ua.removeListener('transactionDestroyed', transactionsListener);\n        ua.transport.disconnect();\n      }\n    }\n\n    this.logger.log('user requested closure...');\n\n    if (this.status === C.STATUS_USER_CLOSED) {\n      this.logger.warn('UA already closed');\n      return this;\n    } // Clear transportRecoveryTimer\n\n\n    SIP.Timers.clearTimeout(this.transportRecoveryTimer); // Close registerContext\n\n    this.logger.log('closing registerContext');\n    this.registerContext.close(); // Run  _terminate_ on every Session\n\n    for (session in this.sessions) {\n      this.logger.log('closing session ' + session);\n      this.sessions[session].terminate();\n    } //Run _close_ on every Subscription\n\n\n    for (subscription in this.subscriptions) {\n      this.logger.log('unsubscribing from subscription ' + subscription);\n      this.subscriptions[subscription].close();\n    } // Run  _close_ on every applicant\n\n\n    for (applicant in this.applicants) {\n      this.applicants[applicant].close();\n    }\n\n    this.status = C.STATUS_USER_CLOSED;\n    /*\n     * If the remaining transactions are all INVITE transactions, there is no need to\n     * wait anymore because every session has already been closed by this method.\n     * - locally originated sessions where terminated (CANCEL or BYE)\n     * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n     * Remaining INVITE transactions belong tho sessions that where answered. This are in\n     * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n     */\n\n    if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n      if (this.transport) {\n        this.transport.disconnect();\n      }\n    } else {\n      this.on('transactionDestroyed', transactionsListener);\n    }\n\n    return this;\n  };\n  /**\n   * Connect to the WS server if status = STATUS_INIT.\n   * Resume UA after being closed.\n   *\n   */\n\n\n  UA.prototype.start = function () {\n    var server;\n    this.logger.log('user requested startup...');\n\n    if (this.status === C.STATUS_INIT) {\n      server = this.getNextWsServer();\n      this.status = C.STATUS_STARTING;\n      new SIP.Transport(this, server);\n    } else if (this.status === C.STATUS_USER_CLOSED) {\n      this.logger.log('resuming');\n      this.status = C.STATUS_READY;\n      this.transport.connect();\n    } else if (this.status === C.STATUS_STARTING) {\n      this.logger.log('UA is in STARTING status, not opening new connection');\n    } else if (this.status === C.STATUS_READY) {\n      this.logger.log('UA is in READY status, not resuming');\n    } else {\n      this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n    }\n\n    return this;\n  };\n  /**\n   * Normalize a string into a valid SIP request URI\n   *\n   * @param {String} target\n   *\n   * @returns {SIP.URI|undefined}\n   */\n\n\n  UA.prototype.normalizeTarget = function (target) {\n    return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n  }; //===============================\n  //  Private (For internal use)\n  //===============================\n\n\n  UA.prototype.saveCredentials = function (credentials) {\n    this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n    this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n    return this;\n  };\n\n  UA.prototype.getCredentials = function (request) {\n    var realm, credentials;\n    realm = request.ruri.host;\n\n    if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n      credentials = this.cache.credentials[realm][request.ruri];\n      credentials.method = request.method;\n    }\n\n    return credentials;\n  };\n\n  UA.prototype.getLogger = function (category, label) {\n    return this.log.getLogger(category, label);\n  }; //==============================\n  // Event Handlers\n  //==============================\n\n  /**\n   * Transport Close event\n   * @private\n   * @event\n   * @param {SIP.Transport} transport.\n   */\n\n\n  UA.prototype.onTransportClosed = function (transport) {\n    // Run _onTransportError_ callback on every client transaction using _transport_\n    var type,\n        idx,\n        length,\n        client_transactions = ['nict', 'ict', 'nist', 'ist'];\n    transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;\n    this.logger.log('connection state set to ' + SIP.Transport.C.STATUS_DISCONNECTED);\n    length = client_transactions.length;\n\n    for (type = 0; type < length; type++) {\n      for (idx in this.transactions[client_transactions[type]]) {\n        this.transactions[client_transactions[type]][idx].onTransportError();\n      }\n    } // Close sessions if GRUU is not being used\n\n\n    if (!this.contact.pub_gruu) {\n      this.closeSessionsOnTransportError();\n    }\n  };\n  /**\n   * Unrecoverable transport event.\n   * Connection reattempt logic has been done and didn't success.\n   * @private\n   * @event\n   * @param {SIP.Transport} transport.\n   */\n\n\n  UA.prototype.onTransportError = function (transport) {\n    var server;\n    this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to ' + SIP.Transport.C.STATUS_ERROR); // Close sessions.\n    //Mark this transport as 'down'\n\n    transport.server.status = SIP.Transport.C.STATUS_ERROR;\n    this.emit('disconnected', {\n      transport: transport\n    }); // try the next transport if the UA isn't closed\n\n    if (this.status === C.STATUS_USER_CLOSED) {\n      return;\n    }\n\n    server = this.getNextWsServer();\n\n    if (server) {\n      new SIP.Transport(this, server);\n    } else {\n      this.closeSessionsOnTransportError();\n\n      if (!this.error || this.error !== C.NETWORK_ERROR) {\n        this.status = C.STATUS_NOT_READY;\n        this.error = C.NETWORK_ERROR;\n      } // Transport Recovery process\n\n\n      this.recoverTransport();\n    }\n  };\n  /**\n   * Transport connection event.\n   * @private\n   * @event\n   * @param {SIP.Transport} transport.\n   */\n\n\n  UA.prototype.onTransportConnected = function (transport) {\n    this.transport = transport; // Reset transport recovery counter\n\n    this.transportRecoverAttempts = 0;\n    transport.server.status = SIP.Transport.C.STATUS_READY;\n    this.logger.log('connection state set to ' + SIP.Transport.C.STATUS_READY);\n\n    if (this.status === C.STATUS_USER_CLOSED) {\n      return;\n    }\n\n    this.status = C.STATUS_READY;\n    this.error = null;\n\n    if (this.configuration.register) {\n      this.configuration.authenticationFactory.initialize().then(function () {\n        this.registerContext.onTransportConnected();\n      }.bind(this));\n    }\n\n    this.emit('connected', {\n      transport: transport\n    });\n  };\n  /**\n   * Transport connecting event\n   * @private\n   * @param {SIP.Transport} transport.\n   * #param {Integer} attempts.\n   */\n\n\n  UA.prototype.onTransportConnecting = function (transport, attempts) {\n    this.emit('connecting', {\n      transport: transport,\n      attempts: attempts\n    });\n  };\n  /**\n   * new Transaction\n   * @private\n   * @param {SIP.Transaction} transaction.\n   */\n\n\n  UA.prototype.newTransaction = function (transaction) {\n    this.transactions[transaction.type][transaction.id] = transaction;\n    this.emit('newTransaction', {\n      transaction: transaction\n    });\n  };\n  /**\n   * destroy Transaction\n   * @private\n   * @param {SIP.Transaction} transaction.\n   */\n\n\n  UA.prototype.destroyTransaction = function (transaction) {\n    delete this.transactions[transaction.type][transaction.id];\n    this.emit('transactionDestroyed', {\n      transaction: transaction\n    });\n  }; //=========================\n  // receiveRequest\n  //=========================\n\n  /**\n   * Request reception\n   * @private\n   * @param {SIP.IncomingRequest} request.\n   */\n\n\n  UA.prototype.receiveRequest = function (request) {\n    var dialog,\n        session,\n        message,\n        method = request.method,\n        transaction,\n        replaces,\n        replacedDialog,\n        self = this;\n\n    function ruriMatches(uri) {\n      return uri && uri.user === request.ruri.user;\n    } // Check that request URI points to us\n\n\n    if (!(ruriMatches(this.configuration.uri) || ruriMatches(this.contact.uri) || ruriMatches(this.contact.pub_gruu) || ruriMatches(this.contact.temp_gruu))) {\n      this.logger.warn('Request-URI does not point to us');\n\n      if (request.method !== SIP.C.ACK) {\n        request.reply_sl(404);\n      }\n\n      return;\n    } // Check request URI scheme\n\n\n    if (request.ruri.scheme === SIP.C.SIPS) {\n      request.reply_sl(416);\n      return;\n    } // Check transaction\n\n\n    if (SIP.Transactions.checkTransaction(this, request)) {\n      return;\n    }\n    /* RFC3261 12.2.2\n     * Requests that do not change in any way the state of a dialog may be\n     * received within a dialog (for example, an OPTIONS request).\n     * They are processed as if they had been received outside the dialog.\n     */\n\n\n    if (method === SIP.C.OPTIONS) {\n      new SIP.Transactions.NonInviteServerTransaction(request, this);\n      request.reply(200, null, ['Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString(), 'Accept: ' + C.ACCEPTED_BODY_TYPES]);\n    } else if (method === SIP.C.MESSAGE) {\n      message = new SIP.ServerContext(this, request);\n      message.body = request.body;\n      message.content_type = request.getHeader('Content-Type') || 'text/plain';\n      request.reply(200, null);\n      this.emit('message', message);\n    } else if (method !== SIP.C.INVITE && method !== SIP.C.ACK) {\n      // Let those methods pass through to normal processing for now.\n      transaction = new SIP.ServerContext(this, request);\n    } // Initial Request\n\n\n    if (!request.to_tag) {\n      switch (method) {\n        case SIP.C.INVITE:\n          replaces = this.configuration.replaces !== SIP.C.supported.UNSUPPORTED && request.parseHeader('replaces');\n\n          if (replaces) {\n            replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];\n\n            if (!replacedDialog) {\n              //Replaced header without a matching dialog, reject\n              request.reply_sl(481, null);\n              return;\n            } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {\n              request.reply_sl(603, null);\n              return;\n            } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {\n              request.reply_sl(486, null);\n              return;\n            }\n          }\n\n          var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;\n\n          if (!isMediaSupported || isMediaSupported()) {\n            session = new SIP.InviteServerContext(this, request);\n            session.replacee = replacedDialog && replacedDialog.owner;\n            session.on('invite', function () {\n              self.emit('invite', this);\n            });\n          } else {\n            this.logger.warn('INVITE received but WebRTC is not supported');\n            request.reply(488);\n          }\n\n          break;\n\n        case SIP.C.BYE:\n          // Out of dialog BYE received\n          request.reply(481);\n          break;\n\n        case SIP.C.CANCEL:\n          session = this.findSession(request);\n\n          if (session) {\n            session.receiveRequest(request);\n          } else {\n            this.logger.warn('received CANCEL request for a non existent session');\n          }\n\n          break;\n\n        case SIP.C.ACK:\n          /* Absorb it.\n           * ACK request without a corresponding Invite Transaction\n           * and without To tag.\n           */\n          break;\n\n        case SIP.C.NOTIFY:\n          if (this.configuration.allowLegacyNotifications && this.listeners('notify').length > 0) {\n            request.reply(200, null);\n            self.emit('notify', {\n              request: request\n            });\n          } else {\n            request.reply(481, 'Subscription does not exist');\n          }\n\n          break;\n\n        default:\n          request.reply(405);\n          break;\n      }\n    } // In-dialog request\n    else {\n        dialog = this.findDialog(request);\n\n        if (dialog) {\n          if (method === SIP.C.INVITE) {\n            new SIP.Transactions.InviteServerTransaction(request, this);\n          }\n\n          dialog.receiveRequest(request);\n        } else if (method === SIP.C.NOTIFY) {\n          session = this.findSession(request);\n\n          if (session) {\n            session.receiveRequest(request);\n          } else {\n            this.logger.warn('received NOTIFY request for a non existent session');\n            request.reply(481, 'Subscription does not exist');\n          }\n        }\n        /* RFC3261 12.2.2\n         * Request with to tag, but no matching dialog found.\n         * Exception: ACK for an Invite request for which a dialog has not\n         * been created.\n         */\n        else {\n            if (method !== SIP.C.ACK) {\n              request.reply(481);\n            }\n          }\n      }\n  }; //=================\n  // Utils\n  //=================\n\n  /**\n   * Get the session to which the request belongs to, if any.\n   * @private\n   * @param {SIP.IncomingRequest} request.\n   * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n   */\n\n\n  UA.prototype.findSession = function (request) {\n    return this.sessions[request.call_id + request.from_tag] || this.sessions[request.call_id + request.to_tag] || null;\n  };\n  /**\n   * Get the dialog to which the request belongs to, if any.\n   * @private\n   * @param {SIP.IncomingRequest}\n   * @returns {SIP.Dialog|null}\n   */\n\n\n  UA.prototype.findDialog = function (request) {\n    return this.dialogs[request.call_id + request.from_tag + request.to_tag] || this.dialogs[request.call_id + request.to_tag + request.from_tag] || null;\n  };\n  /**\n   * Retrieve the next server to which connect.\n   * @private\n   * @returns {Object} ws_server\n   */\n\n\n  UA.prototype.getNextWsServer = function () {\n    // Order servers by weight\n    var idx,\n        length,\n        ws_server,\n        candidates = [];\n    length = this.configuration.wsServers.length;\n\n    for (idx = 0; idx < length; idx++) {\n      ws_server = this.configuration.wsServers[idx];\n\n      if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {\n        continue;\n      } else if (candidates.length === 0) {\n        candidates.push(ws_server);\n      } else if (ws_server.weight > candidates[0].weight) {\n        candidates = [ws_server];\n      } else if (ws_server.weight === candidates[0].weight) {\n        candidates.push(ws_server);\n      }\n    }\n\n    idx = Math.floor(Math.random() * candidates.length);\n    return candidates[idx];\n  };\n  /**\n   * Close all sessions on transport error.\n   * @private\n   */\n\n\n  UA.prototype.closeSessionsOnTransportError = function () {\n    var idx; // Run _transportError_ for every Session\n\n    for (idx in this.sessions) {\n      this.sessions[idx].onTransportError();\n    } // Call registerContext _onTransportClosed_\n\n\n    this.registerContext.onTransportClosed();\n  };\n\n  UA.prototype.recoverTransport = function (ua) {\n    var idx, length, k, nextRetry, count, server;\n    ua = ua || this;\n    count = ua.transportRecoverAttempts;\n    length = ua.configuration.wsServers.length;\n\n    for (idx = 0; idx < length; idx++) {\n      ua.configuration.wsServers[idx].status = 0;\n    }\n\n    server = ua.getNextWsServer();\n    k = Math.floor(Math.random() * Math.pow(2, count) + 1);\n    nextRetry = k * ua.configuration.connectionRecoveryMinInterval;\n\n    if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {\n      this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');\n      nextRetry = ua.configuration.connectionRecoveryMinInterval;\n      count = 0;\n    }\n\n    this.logger.log('next connection attempt in ' + nextRetry + ' seconds');\n    this.transportRecoveryTimer = SIP.Timers.setTimeout(function () {\n      ua.transportRecoverAttempts = count + 1;\n      new SIP.Transport(ua, server);\n    }, nextRetry * 1000);\n  };\n\n  function checkAuthenticationFactory(authenticationFactory) {\n    if (!(authenticationFactory instanceof Function)) {\n      return;\n    }\n\n    if (!authenticationFactory.initialize) {\n      authenticationFactory.initialize = function initialize() {\n        return SIP.Utils.Promise.resolve();\n      };\n    }\n\n    return authenticationFactory;\n  }\n  /**\n   * Configuration load.\n   * @private\n   * returns {Boolean}\n   */\n\n\n  UA.prototype.loadConfig = function (configuration) {\n    // Settings and default values\n    var parameter,\n        value,\n        checked_value,\n        hostportParams,\n        registrarServer,\n        settings = {\n      /* Host address\n      * Value to be set in Via sent_by and host part of Contact FQDN\n      */\n      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n      wsServers: [{\n        scheme: 'WSS',\n        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n        status: 0,\n        weight: 0,\n        ws_uri: 'wss://edge.sip.onsip.com'\n      }],\n      // Password\n      password: null,\n      // Registration parameters\n      registerExpires: 600,\n      register: true,\n      registrarServer: null,\n      // Transport related parameters\n      wsServerMaxReconnection: 3,\n      wsServerReconnectionTimeout: 4,\n      connectionRecoveryMinInterval: 2,\n      connectionRecoveryMaxInterval: 30,\n      keepAliveInterval: 0,\n      extraSupported: [],\n      usePreloadedRoute: false,\n      //string to be inserted into User-Agent request header\n      userAgentString: SIP.C.USER_AGENT,\n      // Session parameters\n      iceCheckingTimeout: 5000,\n      noAnswerTimeout: 60,\n      stunServers: ['stun:stun.l.google.com:19302'],\n      turnServers: [],\n      // Logging parameters\n      traceSip: false,\n      // Hacks\n      hackViaTcp: false,\n      hackIpInContact: false,\n      hackWssInTransport: false,\n      hackAllowUnregisteredOptionTags: false,\n      hackCleanJitsiSdpImageattr: false,\n      hackStripTcp: false,\n      contactTransport: 'ws',\n      forceRport: false,\n      //autostarting\n      autostart: true,\n      //Reliable Provisional Responses\n      rel100: SIP.C.supported.UNSUPPORTED,\n      // Replaces header (RFC 3891)\n      // http://tools.ietf.org/html/rfc3891\n      replaces: SIP.C.supported.UNSUPPORTED,\n      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,\n      authenticationFactory: checkAuthenticationFactory(function authenticationFactory(ua) {\n        return new SIP.DigestAuthentication(ua);\n      }),\n      allowLegacyNotifications: false\n    }; // Pre-Configuration\n\n    function aliasUnderscored(parameter, logger) {\n      var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n        return m[0] + '_' + m[1].toLowerCase();\n      });\n\n      if (parameter === underscored) {\n        return;\n      }\n\n      var hasParameter = configuration.hasOwnProperty(parameter);\n\n      if (configuration.hasOwnProperty(underscored)) {\n        logger.warn(underscored + ' is deprecated, please use ' + parameter);\n\n        if (hasParameter) {\n          logger.warn(parameter + ' overriding ' + underscored);\n        }\n      }\n\n      configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n    } // Check Mandatory parameters\n\n\n    for (parameter in UA.configuration_check.mandatory) {\n      aliasUnderscored(parameter, this.logger);\n\n      if (!configuration.hasOwnProperty(parameter)) {\n        throw new SIP.Exceptions.ConfigurationError(parameter);\n      } else {\n        value = configuration[parameter];\n        checked_value = UA.configuration_check.mandatory[parameter](value);\n\n        if (checked_value !== undefined) {\n          settings[parameter] = checked_value;\n        } else {\n          throw new SIP.Exceptions.ConfigurationError(parameter, value);\n        }\n      }\n    }\n\n    SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);\n    var emptyArraysAllowed = ['stunServers', 'turnServers']; // Check Optional parameters\n\n    for (parameter in UA.configuration_check.optional) {\n      aliasUnderscored(parameter, this.logger);\n\n      if (configuration.hasOwnProperty(parameter)) {\n        value = configuration[parameter]; // If the parameter value is an empty array, but shouldn't be, apply its default value.\n\n        if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) {\n          continue;\n        } // If the parameter value is null, empty string, or undefined then apply its default value.\n\n\n        if (value === null || value === \"\" || value === undefined) {\n          continue;\n        } // If it's a number with NaN value then also apply its default value.\n        // NOTE: JS does not allow \"value === NaN\", the following does the work:\n        else if (typeof value === 'number' && isNaN(value)) {\n            continue;\n          }\n\n        checked_value = UA.configuration_check.optional[parameter](value);\n\n        if (checked_value !== undefined) {\n          settings[parameter] = checked_value;\n        } else {\n          throw new SIP.Exceptions.ConfigurationError(parameter, value);\n        }\n      }\n    } // Sanity Checks\n    // Connection recovery intervals\n\n\n    if (settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {\n      throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);\n    } // Post Configuration Process\n    // Allow passing 0 number as displayName.\n\n\n    if (settings.displayName === 0) {\n      settings.displayName = '0';\n    } // Instance-id for GRUU\n\n\n    if (!settings.instanceId) {\n      settings.instanceId = SIP.Utils.newUUID();\n    } // sipjsId instance parameter. Static random tag of length 5\n\n\n    settings.sipjsId = SIP.Utils.createRandomToken(5); // String containing settings.uri without scheme and user.\n\n    hostportParams = settings.uri.clone();\n    hostportParams.user = null;\n    settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');\n    /* Check whether authorizationUser is explicitly defined.\n     * Take 'settings.uri.user' value if not.\n     */\n\n    if (!settings.authorizationUser) {\n      settings.authorizationUser = settings.uri.user;\n    }\n    /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n\n\n    if (!settings.registrarServer) {\n      registrarServer = settings.uri.clone();\n      registrarServer.user = null;\n      settings.registrarServer = registrarServer;\n    } // User noAnswerTimeout\n\n\n    settings.noAnswerTimeout = settings.noAnswerTimeout * 1000; // Via Host\n\n    if (settings.hackIpInContact) {\n      if (typeof settings.hackIpInContact === 'boolean') {\n        settings.viaHost = SIP.Utils.getRandomTestNetIP();\n      } else if (typeof settings.hackIpInContact === 'string') {\n        settings.viaHost = settings.hackIpInContact;\n      }\n    } // Contact transport parameter\n\n\n    if (settings.hackWssInTransport) {\n      settings.contactTransport = 'wss';\n    }\n\n    this.contact = {\n      pub_gruu: null,\n      temp_gruu: null,\n      uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {\n        transport: settings.contactTransport\n      }),\n      toString: function toString(options) {\n        options = options || {};\n        var anonymous = options.anonymous || null,\n            outbound = options.outbound || null,\n            contact = '<';\n\n        if (anonymous) {\n          contact += (this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=' + settings.contactTransport).toString();\n        } else {\n          contact += (this.pub_gruu || this.uri).toString();\n        }\n\n        if (outbound) {\n          contact += ';ob';\n        }\n\n        contact += '>';\n        return contact;\n      }\n    }; // media overrides mediaConstraints\n\n    SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger); // Fill the value of the configuration_skeleton\n\n    for (parameter in settings) {\n      UA.configuration_skeleton[parameter].value = settings[parameter];\n    }\n\n    Object.defineProperties(this.configuration, UA.configuration_skeleton); // Clean UA.configuration_skeleton\n\n    for (parameter in settings) {\n      UA.configuration_skeleton[parameter].value = '';\n    }\n\n    this.logger.log('configuration parameters after validation:');\n\n    for (parameter in settings) {\n      switch (parameter) {\n        case 'uri':\n        case 'registrarServer':\n        case 'mediaHandlerFactory':\n          this.logger.log('· ' + parameter + ': ' + settings[parameter]);\n          break;\n\n        case 'password':\n          this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');\n          break;\n\n        default:\n          this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n      }\n    }\n\n    return;\n  };\n  /**\n   * Configuration Object skeleton.\n   * @private\n   */\n\n\n  UA.configuration_skeleton = function () {\n    var idx,\n        parameter,\n        skeleton = {},\n        parameters = [// Internal parameters\n    \"sipjsId\", \"hostportParams\", // Optional user configurable parameters\n    \"uri\", \"wsServers\", \"authorizationUser\", \"connectionRecoveryMaxInterval\", \"connectionRecoveryMinInterval\", \"keepAliveInterval\", \"extraSupported\", \"displayName\", \"hackViaTcp\", // false.\n    \"hackIpInContact\", //false\n    \"hackWssInTransport\", //false\n    \"hackAllowUnregisteredOptionTags\", //false\n    \"hackCleanJitsiSdpImageattr\", //false\n    \"hackStripTcp\", //false\n    \"contactTransport\", // 'ws'\n    \"forceRport\", // false\n    \"iceCheckingTimeout\", \"instanceId\", \"noAnswerTimeout\", // 30 seconds.\n    \"password\", \"registerExpires\", // 600 seconds.\n    \"registrarServer\", \"reliable\", \"rel100\", \"replaces\", \"userAgentString\", //SIP.C.USER_AGENT\n    \"autostart\", \"stunServers\", \"traceSip\", \"turnServers\", \"usePreloadedRoute\", \"wsServerMaxReconnection\", \"wsServerReconnectionTimeout\", \"mediaHandlerFactory\", \"media\", \"mediaConstraints\", \"authenticationFactory\", \"allowLegacyNotifications\", // Post-configuration generated parameters\n    \"via_core_value\", \"viaHost\"];\n\n    for (idx in parameters) {\n      parameter = parameters[idx];\n      skeleton[parameter] = {\n        value: '',\n        writable: false,\n        configurable: false\n      };\n    }\n\n    skeleton['register'] = {\n      value: '',\n      writable: true,\n      configurable: false\n    };\n    return skeleton;\n  }();\n  /**\n   * Configuration checker.\n   * @private\n   * @return {Boolean}\n   */\n\n\n  UA.configuration_check = {\n    mandatory: {},\n    optional: {\n      uri: function uri(_uri) {\n        var parsed;\n\n        if (!/^sip:/i.test(_uri)) {\n          _uri = SIP.C.SIP + ':' + _uri;\n        }\n\n        parsed = SIP.URI.parse(_uri);\n\n        if (!parsed) {\n          return;\n        } else if (!parsed.user) {\n          return;\n        } else {\n          return parsed;\n        }\n      },\n      //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n      wsServers: function wsServers(_wsServers) {\n        var idx, length, url;\n        /* Allow defining wsServers parameter as:\n         *  String: \"host\"\n         *  Array of Strings: [\"host1\", \"host2\"]\n         *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n         *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n         */\n\n        if (typeof _wsServers === 'string') {\n          _wsServers = [{\n            ws_uri: _wsServers\n          }];\n        } else if (_wsServers instanceof Array) {\n          length = _wsServers.length;\n\n          for (idx = 0; idx < length; idx++) {\n            if (typeof _wsServers[idx] === 'string') {\n              _wsServers[idx] = {\n                ws_uri: _wsServers[idx]\n              };\n            }\n          }\n        } else {\n          return;\n        }\n\n        if (_wsServers.length === 0) {\n          return false;\n        }\n\n        length = _wsServers.length;\n\n        for (idx = 0; idx < length; idx++) {\n          if (!_wsServers[idx].ws_uri) {\n            return;\n          }\n\n          if (_wsServers[idx].weight && !Number(_wsServers[idx].weight)) {\n            return;\n          }\n\n          url = SIP.Grammar.parse(_wsServers[idx].ws_uri, 'absoluteURI');\n\n          if (url === -1) {\n            return;\n          } else if (['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {\n            return;\n          } else {\n            _wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';\n\n            if (!_wsServers[idx].weight) {\n              _wsServers[idx].weight = 0;\n            }\n\n            _wsServers[idx].status = 0;\n            _wsServers[idx].scheme = url.scheme.toUpperCase();\n          }\n        }\n\n        return _wsServers;\n      },\n      authorizationUser: function authorizationUser(_authorizationUser) {\n        if (SIP.Grammar.parse('\"' + _authorizationUser + '\"', 'quoted_string') === -1) {\n          return;\n        } else {\n          return _authorizationUser;\n        }\n      },\n      connectionRecoveryMaxInterval: function connectionRecoveryMaxInterval(_connectionRecoveryMaxInterval) {\n        var value;\n\n        if (SIP.Utils.isDecimal(_connectionRecoveryMaxInterval)) {\n          value = Number(_connectionRecoveryMaxInterval);\n\n          if (value > 0) {\n            return value;\n          }\n        }\n      },\n      connectionRecoveryMinInterval: function connectionRecoveryMinInterval(_connectionRecoveryMinInterval) {\n        var value;\n\n        if (SIP.Utils.isDecimal(_connectionRecoveryMinInterval)) {\n          value = Number(_connectionRecoveryMinInterval);\n\n          if (value > 0) {\n            return value;\n          }\n        }\n      },\n      displayName: function displayName(_displayName) {\n        if (SIP.Grammar.parse('\"' + _displayName + '\"', 'displayName') === -1) {\n          return;\n        } else {\n          return _displayName;\n        }\n      },\n      hackViaTcp: function hackViaTcp(_hackViaTcp) {\n        if (typeof _hackViaTcp === 'boolean') {\n          return _hackViaTcp;\n        }\n      },\n      hackIpInContact: function hackIpInContact(_hackIpInContact) {\n        if (typeof _hackIpInContact === 'boolean') {\n          return _hackIpInContact;\n        } else if (typeof _hackIpInContact === 'string' && SIP.Grammar.parse(_hackIpInContact, 'host') !== -1) {\n          return _hackIpInContact;\n        }\n      },\n      iceCheckingTimeout: function iceCheckingTimeout(_iceCheckingTimeout) {\n        if (SIP.Utils.isDecimal(_iceCheckingTimeout)) {\n          return Math.max(500, _iceCheckingTimeout);\n        }\n      },\n      hackWssInTransport: function hackWssInTransport(_hackWssInTransport) {\n        if (typeof _hackWssInTransport === 'boolean') {\n          return _hackWssInTransport;\n        }\n      },\n      hackAllowUnregisteredOptionTags: function hackAllowUnregisteredOptionTags(_hackAllowUnregisteredOptionTags) {\n        if (typeof _hackAllowUnregisteredOptionTags === 'boolean') {\n          return _hackAllowUnregisteredOptionTags;\n        }\n      },\n      hackCleanJitsiSdpImageattr: function hackCleanJitsiSdpImageattr(_hackCleanJitsiSdpImageattr) {\n        if (typeof _hackCleanJitsiSdpImageattr === 'boolean') {\n          return _hackCleanJitsiSdpImageattr;\n        }\n      },\n      hackStripTcp: function hackStripTcp(_hackStripTcp) {\n        if (typeof _hackStripTcp === 'boolean') {\n          return _hackStripTcp;\n        }\n      },\n      contactTransport: function contactTransport(_contactTransport) {\n        if (typeof _contactTransport === 'string') {\n          return _contactTransport;\n        }\n      },\n      forceRport: function forceRport(_forceRport) {\n        if (typeof _forceRport === 'boolean') {\n          return _forceRport;\n        }\n      },\n      instanceId: function instanceId(_instanceId) {\n        if (typeof _instanceId !== 'string') {\n          return;\n        }\n\n        if (/^uuid:/i.test(_instanceId)) {\n          _instanceId = _instanceId.substr(5);\n        }\n\n        if (SIP.Grammar.parse(_instanceId, 'uuid') === -1) {\n          return;\n        } else {\n          return _instanceId;\n        }\n      },\n      keepAliveInterval: function keepAliveInterval(_keepAliveInterval) {\n        var value;\n\n        if (SIP.Utils.isDecimal(_keepAliveInterval)) {\n          value = Number(_keepAliveInterval);\n\n          if (value > 0) {\n            return value;\n          }\n        }\n      },\n      extraSupported: function extraSupported(optionTags) {\n        var idx, length;\n\n        if (!(optionTags instanceof Array)) {\n          return;\n        }\n\n        length = optionTags.length;\n\n        for (idx = 0; idx < length; idx++) {\n          if (typeof optionTags[idx] !== 'string') {\n            return;\n          }\n        }\n\n        return optionTags;\n      },\n      noAnswerTimeout: function noAnswerTimeout(_noAnswerTimeout) {\n        var value;\n\n        if (SIP.Utils.isDecimal(_noAnswerTimeout)) {\n          value = Number(_noAnswerTimeout);\n\n          if (value > 0) {\n            return value;\n          }\n        }\n      },\n      password: function password(_password) {\n        return String(_password);\n      },\n      rel100: function rel100(_rel) {\n        if (_rel === SIP.C.supported.REQUIRED) {\n          return SIP.C.supported.REQUIRED;\n        } else if (_rel === SIP.C.supported.SUPPORTED) {\n          return SIP.C.supported.SUPPORTED;\n        } else {\n          return SIP.C.supported.UNSUPPORTED;\n        }\n      },\n      replaces: function replaces(_replaces) {\n        if (_replaces === SIP.C.supported.REQUIRED) {\n          return SIP.C.supported.REQUIRED;\n        } else if (_replaces === SIP.C.supported.SUPPORTED) {\n          return SIP.C.supported.SUPPORTED;\n        } else {\n          return SIP.C.supported.UNSUPPORTED;\n        }\n      },\n      register: function register(_register) {\n        if (typeof _register === 'boolean') {\n          return _register;\n        }\n      },\n      registerExpires: function registerExpires(_registerExpires) {\n        var value;\n\n        if (SIP.Utils.isDecimal(_registerExpires)) {\n          value = Number(_registerExpires);\n\n          if (value > 0) {\n            return value;\n          }\n        }\n      },\n      registrarServer: function registrarServer(_registrarServer) {\n        var parsed;\n\n        if (typeof _registrarServer !== 'string') {\n          return;\n        }\n\n        if (!/^sip:/i.test(_registrarServer)) {\n          _registrarServer = SIP.C.SIP + ':' + _registrarServer;\n        }\n\n        parsed = SIP.URI.parse(_registrarServer);\n\n        if (!parsed) {\n          return;\n        } else if (parsed.user) {\n          return;\n        } else {\n          return parsed;\n        }\n      },\n      stunServers: function stunServers(_stunServers) {\n        var idx, length, stun_server;\n\n        if (typeof _stunServers === 'string') {\n          _stunServers = [_stunServers];\n        } else if (!(_stunServers instanceof Array)) {\n          return;\n        }\n\n        length = _stunServers.length;\n\n        for (idx = 0; idx < length; idx++) {\n          stun_server = _stunServers[idx];\n\n          if (!/^stuns?:/.test(stun_server)) {\n            stun_server = 'stun:' + stun_server;\n          }\n\n          if (SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {\n            return;\n          } else {\n            _stunServers[idx] = stun_server;\n          }\n        }\n\n        return _stunServers;\n      },\n      traceSip: function traceSip(_traceSip) {\n        if (typeof _traceSip === 'boolean') {\n          return _traceSip;\n        }\n      },\n      turnServers: function turnServers(_turnServers) {\n        var idx, jdx, length, turn_server, num_turn_server_urls, url;\n\n        if (_turnServers instanceof Array) {// Do nothing\n        } else {\n          _turnServers = [_turnServers];\n        }\n\n        length = _turnServers.length;\n\n        for (idx = 0; idx < length; idx++) {\n          turn_server = _turnServers[idx]; //Backwards compatibility: Allow defining the turn_server url with the 'server' property.\n\n          if (turn_server.server) {\n            turn_server.urls = [turn_server.server];\n          }\n\n          if (!turn_server.urls || !turn_server.username || !turn_server.password) {\n            return;\n          }\n\n          if (turn_server.urls instanceof Array) {\n            num_turn_server_urls = turn_server.urls.length;\n          } else {\n            turn_server.urls = [turn_server.urls];\n            num_turn_server_urls = 1;\n          }\n\n          for (jdx = 0; jdx < num_turn_server_urls; jdx++) {\n            url = turn_server.urls[jdx];\n\n            if (!/^turns?:/.test(url)) {\n              url = 'turn:' + url;\n            }\n\n            if (SIP.Grammar.parse(url, 'turn_URI') === -1) {\n              return;\n            }\n          }\n        }\n\n        return _turnServers;\n      },\n      userAgentString: function userAgentString(_userAgentString) {\n        if (typeof _userAgentString === 'string') {\n          return _userAgentString;\n        }\n      },\n      usePreloadedRoute: function usePreloadedRoute(_usePreloadedRoute) {\n        if (typeof _usePreloadedRoute === 'boolean') {\n          return _usePreloadedRoute;\n        }\n      },\n      wsServerMaxReconnection: function wsServerMaxReconnection(_wsServerMaxReconnection) {\n        var value;\n\n        if (SIP.Utils.isDecimal(_wsServerMaxReconnection)) {\n          value = Number(_wsServerMaxReconnection);\n\n          if (value > 0) {\n            return value;\n          }\n        }\n      },\n      wsServerReconnectionTimeout: function wsServerReconnectionTimeout(_wsServerReconnectionTimeout) {\n        var value;\n\n        if (SIP.Utils.isDecimal(_wsServerReconnectionTimeout)) {\n          value = Number(_wsServerReconnectionTimeout);\n\n          if (value > 0) {\n            return value;\n          }\n        }\n      },\n      autostart: function autostart(_autostart) {\n        if (typeof _autostart === 'boolean') {\n          return _autostart;\n        }\n      },\n      mediaHandlerFactory: function mediaHandlerFactory(_mediaHandlerFactory) {\n        if (_mediaHandlerFactory instanceof Function) {\n          var promisifiedFactory = function promisifiedFactory() {\n            var mediaHandler = _mediaHandlerFactory.apply(this, arguments);\n\n            function patchMethod(methodName) {\n              var method = mediaHandler[methodName];\n\n              if (method.length > 1) {\n                var callbacksFirst = methodName === 'getDescription';\n                mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);\n              }\n            }\n\n            patchMethod('getDescription');\n            patchMethod('setDescription');\n            return mediaHandler;\n          };\n\n          promisifiedFactory.isSupported = _mediaHandlerFactory.isSupported;\n          return promisifiedFactory;\n        }\n      },\n      authenticationFactory: checkAuthenticationFactory,\n      allowLegacyNotifications: function allowLegacyNotifications(_allowLegacyNotifications) {\n        if (typeof _allowLegacyNotifications === 'boolean') {\n          return _allowLegacyNotifications;\n        }\n      }\n    }\n  };\n  UA.C = C;\n  SIP.UA = UA;\n};","map":null,"metadata":{},"sourceType":"script"}