{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview MediaHandler\n */\n\n/* MediaHandler\n * @class PeerConnection helper Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]\n *        The MediaStreamManager to acquire/release streams from/to.\n *        If not provided, a default MediaStreamManager will be used.\n */\n\nmodule.exports = function (SIP) {\n  var MediaHandler = function MediaHandler(session, options) {\n    options = options || {};\n    this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);\n    this.session = session;\n    this.localMedia = null;\n    this.ready = true;\n    this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);\n    this.audioMuted = false;\n    this.videoMuted = false;\n    this.local_hold = false;\n    this.remote_hold = false; // old init() from here on\n\n    var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n    this.RTCConstraints = options.RTCConstraints || {};\n    this.initPeerConnection(servers);\n\n    function selfEmit(mh, event) {\n      if (mh.mediaStreamManager.on) {\n        mh.mediaStreamManager.on(event, function () {\n          mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));\n        });\n      }\n    }\n\n    selfEmit(this, 'userMediaRequest');\n    selfEmit(this, 'userMedia');\n    selfEmit(this, 'userMediaFailed');\n  };\n\n  MediaHandler.defaultFactory = function defaultFactory(session, options) {\n    return new MediaHandler(session, options);\n  };\n\n  MediaHandler.defaultFactory.isSupported = function () {\n    return SIP.WebRTC.isSupported();\n  };\n\n  MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {\n    // Functions the session can use\n    isReady: {\n      writable: true,\n      value: function isReady() {\n        return this.ready;\n      }\n    },\n    close: {\n      writable: true,\n      value: function close() {\n        this.logger.log('closing PeerConnection');\n        this._remoteStreams = []; // have to check signalingState since this.close() gets called multiple times\n        // TODO figure out why that happens\n\n        if (this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n          this.peerConnection.close();\n\n          if (this.localMedia) {\n            this.mediaStreamManager.release(this.localMedia);\n          }\n        }\n      }\n    },\n\n    /**\n     * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]\n     *        the MediaStream (or the constraints describing it) to be used for the session\n     */\n    getDescription: {\n      writable: true,\n      value: function getDescription(mediaHint) {\n        var self = this;\n        var acquire = self.mediaStreamManager.acquire;\n\n        if (acquire.length > 1) {\n          acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);\n        }\n\n        mediaHint = mediaHint || {};\n\n        if (mediaHint.dataChannel === true) {\n          mediaHint.dataChannel = {};\n        }\n\n        this.mediaHint = mediaHint;\n        /*\n         * 1. acquire streams (skip if MediaStreams passed in)\n         * 2. addStreams\n         * 3. createOffer/createAnswer\n         */\n\n        var streamPromise;\n\n        if (self.localMedia) {\n          self.logger.log('already have local media');\n          streamPromise = SIP.Utils.Promise.resolve(self.localMedia);\n        } else {\n          self.logger.log('acquiring local media');\n          streamPromise = acquire.call(self.mediaStreamManager, mediaHint).then(function acquireSucceeded(streams) {\n            self.logger.log('acquired local media streams');\n            self.localMedia = streams;\n            self.session.connecting();\n            return streams;\n          }, function acquireFailed(err) {\n            self.logger.error('unable to acquire streams');\n            self.logger.error(err);\n            self.session.connecting();\n            throw err;\n          }).then(this.addStreams.bind(this));\n        }\n\n        return streamPromise.then(function streamAdditionSucceeded() {\n          if (self.hasOffer('remote')) {\n            self.peerConnection.ondatachannel = function (evt) {\n              self.dataChannel = evt.channel;\n              self.emit('dataChannel', self.dataChannel);\n            };\n          } else if (mediaHint.dataChannel && self.peerConnection.createDataChannel) {\n            self.dataChannel = self.peerConnection.createDataChannel('sipjs', mediaHint.dataChannel);\n            self.emit('dataChannel', self.dataChannel);\n          }\n\n          self.render();\n          return self.createOfferOrAnswer(self.RTCConstraints);\n        }).then(function (sdp) {\n          sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);\n\n          if (self.local_hold) {\n            // Don't receive media\n            // TODO - This will break for media streams with different directions.\n            if (!/a=(sendrecv|sendonly|recvonly|inactive)/.test(sdp)) {\n              sdp = sdp.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n            } else {\n              sdp = sdp.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n              sdp = sdp.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n            }\n          }\n\n          return {\n            body: sdp,\n            contentType: 'application/sdp'\n          };\n        });\n      }\n    },\n\n    /**\n     * Check if a SIP message contains a session description.\n     * @param {SIP.SIPMessage} message\n     * @returns {boolean}\n     */\n    hasDescription: {\n      writeable: true,\n      value: function hasDescription(message) {\n        return message.getHeader('Content-Type') === 'application/sdp' && !!message.body;\n      }\n    },\n\n    /**\n     * Set the session description contained in a SIP message.\n     * @param {SIP.SIPMessage} message\n     * @returns {Promise}\n     */\n    setDescription: {\n      writable: true,\n      value: function setDescription(message) {\n        var sdp = message.body;\n        this.remote_hold = /a=(sendonly|inactive)/.test(sdp);\n        sdp = SIP.Hacks.Firefox.cannotHandleExtraWhitespace(sdp);\n        sdp = SIP.Hacks.AllBrowsers.maskDtls(sdp);\n        var rawDescription = {\n          type: this.hasOffer('local') ? 'answer' : 'offer',\n          sdp: sdp\n        };\n        this.emit('setDescription', rawDescription);\n        var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);\n        return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);\n      }\n    },\n\n    /**\n     * If the Session associated with this MediaHandler were to be referred,\n     * what mediaHint should be provided to the UA's invite method?\n     */\n    getReferMedia: {\n      writable: true,\n      value: function getReferMedia() {\n        function hasTracks(trackGetter, stream) {\n          return stream[trackGetter]().length > 0;\n        }\n\n        function bothHaveTracks(trackGetter) {\n          /* jshint validthis:true */\n          return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) && this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));\n        }\n\n        return {\n          constraints: {\n            audio: bothHaveTracks.call(this, 'getAudioTracks'),\n            video: bothHaveTracks.call(this, 'getVideoTracks')\n          }\n        };\n      }\n    },\n    updateIceServers: {\n      writeable: true,\n      value: function value(options) {\n        var servers = this.prepareIceServers(options.stunServers, options.turnServers);\n        this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;\n        this.initPeerConnection(servers);\n        /* once updateIce is implemented correctly, this is better than above\n        //no op if browser does not support this\n        if (!this.peerConnection.updateIce) {\n          return;\n        }\n         this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);\n        */\n      }\n    },\n    // Functions the session can use, but only because it's convenient for the application\n    isMuted: {\n      writable: true,\n      value: function isMuted() {\n        return {\n          audio: this.audioMuted,\n          video: this.videoMuted\n        };\n      }\n    },\n    mute: {\n      writable: true,\n      value: function mute(options) {\n        if (this.getLocalStreams().length === 0) {\n          return;\n        }\n\n        options = options || {\n          audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n          video: this.getLocalStreams()[0].getVideoTracks().length > 0\n        };\n        var audioMuted = false,\n            videoMuted = false;\n\n        if (options.audio && !this.audioMuted) {\n          audioMuted = true;\n          this.audioMuted = true;\n          this.toggleMuteAudio(true);\n        }\n\n        if (options.video && !this.videoMuted) {\n          videoMuted = true;\n          this.videoMuted = true;\n          this.toggleMuteVideo(true);\n        } //REVISIT\n\n\n        if (audioMuted || videoMuted) {\n          return {\n            audio: audioMuted,\n            video: videoMuted\n          };\n          /*this.session.onmute({\n            audio: audioMuted,\n            video: videoMuted\n          });*/\n        }\n      }\n    },\n    unmute: {\n      writable: true,\n      value: function unmute(options) {\n        if (this.getLocalStreams().length === 0) {\n          return;\n        }\n\n        options = options || {\n          audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n          video: this.getLocalStreams()[0].getVideoTracks().length > 0\n        };\n        var audioUnMuted = false,\n            videoUnMuted = false;\n\n        if (options.audio && this.audioMuted) {\n          audioUnMuted = true;\n          this.audioMuted = false;\n          this.toggleMuteAudio(false);\n        }\n\n        if (options.video && this.videoMuted) {\n          videoUnMuted = true;\n          this.videoMuted = false;\n          this.toggleMuteVideo(false);\n        } //REVISIT\n\n\n        if (audioUnMuted || videoUnMuted) {\n          return {\n            audio: audioUnMuted,\n            video: videoUnMuted\n          };\n          /*this.session.onunmute({\n            audio: audioUnMuted,\n            video: videoUnMuted\n          });*/\n        }\n      }\n    },\n    hold: {\n      writable: true,\n      value: function hold() {\n        this.local_hold = true;\n        this.toggleMuteAudio(true);\n        this.toggleMuteVideo(true);\n      }\n    },\n    unhold: {\n      writable: true,\n      value: function unhold() {\n        this.local_hold = false;\n\n        if (!this.audioMuted) {\n          this.toggleMuteAudio(false);\n        }\n\n        if (!this.videoMuted) {\n          this.toggleMuteVideo(false);\n        }\n      }\n    },\n    // Functions the application can use, but not the session\n    getLocalStreams: {\n      writable: true,\n      value: function getLocalStreams() {\n        var pc = this.peerConnection;\n\n        if (pc && pc.signalingState === 'closed') {\n          this.logger.warn('peerConnection is closed, getLocalStreams returning []');\n          return [];\n        }\n\n        return pc.getLocalStreams && pc.getLocalStreams() || pc.localStreams || [];\n      }\n    },\n    getRemoteStreams: {\n      writable: true,\n      value: function getRemoteStreams() {\n        var pc = this.peerConnection;\n\n        if (pc && pc.signalingState === 'closed') {\n          this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');\n          return this._remoteStreams;\n        }\n\n        return pc.getRemoteStreams && pc.getRemoteStreams() || pc.remoteStreams || [];\n      }\n    },\n    render: {\n      writable: true,\n      value: function render(renderHint) {\n        renderHint = renderHint || this.mediaHint && this.mediaHint.render;\n\n        if (!renderHint) {\n          return false;\n        }\n\n        var streamGetters = {\n          local: 'getLocalStreams',\n          remote: 'getRemoteStreams'\n        };\n        Object.keys(streamGetters).forEach(function (loc) {\n          var streamGetter = streamGetters[loc];\n          var streams = this[streamGetter]();\n          SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);\n        }.bind(this));\n      }\n    },\n    // Internal functions\n    hasOffer: {\n      writable: true,\n      value: function hasOffer(where) {\n        var offerState = 'have-' + where + '-offer';\n        return this.peerConnection.signalingState === offerState; // TODO consider signalingStates with 'pranswer'?\n      }\n    },\n    prepareIceServers: {\n      writable: true,\n      value: function prepareIceServers(stunServers, turnServers) {\n        var servers = [],\n            config = this.session.ua.configuration;\n        stunServers = stunServers || config.stunServers;\n        turnServers = turnServers || config.turnServers;\n        [].concat(stunServers).forEach(function (server) {\n          servers.push({\n            'urls': server\n          });\n        });\n        [].concat(turnServers).forEach(function (server) {\n          servers.push({\n            'urls': server.urls,\n            'username': server.username,\n            'credential': server.password\n          });\n        });\n        return servers;\n      }\n    },\n    initPeerConnection: {\n      writable: true,\n      value: function initPeerConnection(servers) {\n        var self = this,\n            config = this.session.ua.configuration;\n        this.onIceCompleted = SIP.Utils.defer();\n        this.onIceCompleted.promise.then(function (pc) {\n          self.emit('iceGatheringComplete', pc);\n\n          if (self.iceCheckingTimer) {\n            SIP.Timers.clearTimeout(self.iceCheckingTimer);\n            self.iceCheckingTimer = null;\n          }\n        });\n\n        if (this.peerConnection) {\n          this.peerConnection.close();\n        }\n\n        this.peerConnection = new SIP.WebRTC.RTCPeerConnection({\n          'iceServers': servers\n        }); // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams\n        // even if peerConnection.onaddstream was just called. In order to make\n        // MediaHandler.prototype.getRemoteStreams work, keep track of them manually\n\n        this._remoteStreams = [];\n\n        this.peerConnection.onaddstream = function (e) {\n          self.logger.log('stream added: ' + e.stream.id);\n\n          self._remoteStreams.push(e.stream);\n\n          self.render();\n          self.emit('addStream', e);\n        };\n\n        this.peerConnection.onremovestream = function (e) {\n          self.logger.log('stream removed: ' + e.stream.id);\n        };\n\n        this.startIceCheckingTimer = function () {\n          if (!self.iceCheckingTimer) {\n            self.iceCheckingTimer = SIP.Timers.setTimeout(function () {\n              self.logger.log('RTCIceChecking Timeout Triggered after ' + config.iceCheckingTimeout + ' milliseconds');\n              self.onIceCompleted.resolve(this);\n            }.bind(this.peerConnection), config.iceCheckingTimeout);\n          }\n        };\n\n        this.peerConnection.onicecandidate = function (e) {\n          self.emit('iceCandidate', e);\n\n          if (e.candidate) {\n            self.logger.log('ICE candidate received: ' + (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n            self.startIceCheckingTimer();\n          } else {\n            self.onIceCompleted.resolve(this);\n          }\n        };\n\n        this.peerConnection.onicegatheringstatechange = function () {\n          self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n\n          if (this.iceGatheringState === 'gathering') {\n            self.emit('iceGathering', this);\n          }\n\n          if (this.iceGatheringState === 'complete') {\n            self.onIceCompleted.resolve(this);\n          }\n        };\n\n        this.peerConnection.oniceconnectionstatechange = function () {\n          //need e for commented out case\n          var stateEvent;\n\n          if (this.iceConnectionState === 'checking') {\n            self.startIceCheckingTimer();\n          }\n\n          switch (this.iceConnectionState) {\n            case 'new':\n              stateEvent = 'iceConnection';\n              break;\n\n            case 'checking':\n              stateEvent = 'iceConnectionChecking';\n              break;\n\n            case 'connected':\n              stateEvent = 'iceConnectionConnected';\n              break;\n\n            case 'completed':\n              stateEvent = 'iceConnectionCompleted';\n              break;\n\n            case 'failed':\n              stateEvent = 'iceConnectionFailed';\n              break;\n\n            case 'disconnected':\n              stateEvent = 'iceConnectionDisconnected';\n              break;\n\n            case 'closed':\n              stateEvent = 'iceConnectionClosed';\n              break;\n\n            default:\n              self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);\n              return;\n          }\n\n          self.emit(stateEvent, this); //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated\n          //normal calls switch from failed to connected in some cases, so checking for failed and terminated\n\n          /*if (this.iceConnectionState === 'failed') {\n            self.session.terminate({\n            cause: SIP.C.causes.RTP_TIMEOUT,\n            status_code: 200,\n            reason_phrase: SIP.C.causes.RTP_TIMEOUT\n          });\n          } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {\n          self.onIceCompleted(this);\n          }*/\n        };\n\n        this.peerConnection.onstatechange = function () {\n          self.logger.log('PeerConnection state changed to \"' + this.readyState + '\"');\n        };\n      }\n    },\n    createOfferOrAnswer: {\n      writable: true,\n      value: function createOfferOrAnswer(constraints) {\n        var self = this;\n        var methodName;\n        var pc = self.peerConnection;\n        self.ready = false;\n        methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n        return SIP.Utils.promisify(pc, methodName, true)(constraints).then(SIP.Utils.promisify(pc, 'setLocalDescription')).then(function onSetLocalDescriptionSuccess() {\n          var deferred = SIP.Utils.defer();\n\n          if (pc.iceConnectionState === 'complete' || pc.iceConnectionState === 'completed') {\n            deferred.resolve();\n          } else {\n            self.onIceCompleted.promise.then(deferred.resolve);\n          }\n\n          return deferred.promise;\n        }).then(function readySuccess() {\n          var sdp = pc.localDescription.sdp;\n          sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);\n          sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);\n          var sdpWrapper = {\n            type: methodName === 'createOffer' ? 'offer' : 'answer',\n            sdp: sdp\n          };\n          self.emit('getDescription', sdpWrapper);\n\n          if (self.session.ua.configuration.hackStripTcp) {\n            sdpWrapper.sdp = sdpWrapper.sdp.replace(/^a=candidate:\\d+ \\d+ tcp .*?\\r\\n/img, \"\");\n          }\n\n          self.ready = true;\n          return sdpWrapper.sdp;\n        }).catch(function methodFailed(e) {\n          self.logger.error(e);\n          self.ready = true;\n          throw new SIP.Exceptions.GetDescriptionError(e);\n        });\n      }\n    },\n    addStreams: {\n      writable: true,\n      value: function addStreams(streams) {\n        try {\n          streams = [].concat(streams);\n          streams.forEach(function (stream) {\n            this.peerConnection.addStream(stream);\n          }, this);\n        } catch (e) {\n          this.logger.error('error adding stream');\n          this.logger.error(e);\n          return SIP.Utils.Promise.reject(e);\n        }\n\n        return SIP.Utils.Promise.resolve();\n      }\n    },\n    toggleMuteHelper: {\n      writable: true,\n      value: function toggleMuteHelper(trackGetter, mute) {\n        this.getLocalStreams().forEach(function (stream) {\n          stream[trackGetter]().forEach(function (track) {\n            track.enabled = !mute;\n          });\n        });\n      }\n    },\n    toggleMuteAudio: {\n      writable: true,\n      value: function toggleMuteAudio(mute) {\n        this.toggleMuteHelper('getAudioTracks', mute);\n      }\n    },\n    toggleMuteVideo: {\n      writable: true,\n      value: function toggleMuteVideo(mute) {\n        this.toggleMuteHelper('getVideoTracks', mute);\n      }\n    }\n  }); // Return since it will be assigned to a variable.\n\n  return MediaHandler;\n};","map":null,"metadata":{},"sourceType":"script"}