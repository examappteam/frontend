{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview DTMF\n */\n\n/**\n * @class DTMF\n * @param {SIP.Session} session\n */\n\nmodule.exports = function (SIP) {\n  var _DTMF,\n      C = {\n    MIN_DURATION: 70,\n    MAX_DURATION: 6000,\n    DEFAULT_DURATION: 100,\n    MIN_INTER_TONE_GAP: 50,\n    DEFAULT_INTER_TONE_GAP: 500\n  };\n\n  _DTMF = function DTMF(session, tone, options) {\n    var duration, interToneGap;\n\n    if (tone === undefined) {\n      throw new TypeError('Not enough arguments');\n    }\n\n    this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n    this.owner = session;\n    this.direction = null;\n    options = options || {};\n    duration = options.duration || null;\n    interToneGap = options.interToneGap || null; // Check tone type\n\n    if (typeof tone === 'string') {\n      tone = tone.toUpperCase();\n    } else if (typeof tone === 'number') {\n      tone = tone.toString();\n    } else {\n      throw new TypeError('Invalid tone: ' + tone);\n    } // Check tone value\n\n\n    if (!tone.match(/^[0-9A-D#*]$/)) {\n      throw new TypeError('Invalid tone: ' + tone);\n    } else {\n      this.tone = tone;\n    } // Check duration\n\n\n    if (duration && !SIP.Utils.isDecimal(duration)) {\n      throw new TypeError('Invalid tone duration: ' + duration);\n    } else if (!duration) {\n      duration = _DTMF.C.DEFAULT_DURATION;\n    } else if (duration < _DTMF.C.MIN_DURATION) {\n      this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to ' + _DTMF.C.MIN_DURATION + ' milliseconds');\n      duration = _DTMF.C.MIN_DURATION;\n    } else if (duration > _DTMF.C.MAX_DURATION) {\n      this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to ' + _DTMF.C.MAX_DURATION + ' milliseconds');\n      duration = _DTMF.C.MAX_DURATION;\n    } else {\n      duration = Math.abs(duration);\n    }\n\n    this.duration = duration; // Check interToneGap\n\n    if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n      throw new TypeError('Invalid interToneGap: ' + interToneGap);\n    } else if (!interToneGap) {\n      interToneGap = _DTMF.C.DEFAULT_INTER_TONE_GAP;\n    } else if (interToneGap < _DTMF.C.MIN_INTER_TONE_GAP) {\n      this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to ' + _DTMF.C.MIN_INTER_TONE_GAP + ' milliseconds');\n      interToneGap = _DTMF.C.MIN_INTER_TONE_GAP;\n    } else {\n      interToneGap = Math.abs(interToneGap);\n    }\n\n    this.interToneGap = interToneGap;\n  };\n\n  _DTMF.prototype = Object.create(SIP.EventEmitter.prototype);\n\n  _DTMF.prototype.send = function (options) {\n    var extraHeaders,\n        body = {};\n    this.direction = 'outgoing'; // Check RTCSession Status\n\n    if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED && this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n      throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n    } // Get DTMF options\n\n\n    options = options || {};\n    extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n    body.contentType = 'application/dtmf-relay';\n    body.body = \"Signal= \" + this.tone + \"\\r\\n\";\n    body.body += \"Duration= \" + this.duration;\n    this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n      extraHeaders: extraHeaders,\n      body: body\n    });\n    this.owner.emit('dtmf', this.request, this);\n  };\n  /**\n   * @private\n   */\n\n\n  _DTMF.prototype.receiveResponse = function (response) {\n    var cause;\n\n    switch (true) {\n      case /^1[0-9]{2}$/.test(response.status_code):\n        // Ignore provisional responses.\n        break;\n\n      case /^2[0-9]{2}$/.test(response.status_code):\n        this.emit('succeeded', {\n          originator: 'remote',\n          response: response\n        });\n        break;\n\n      default:\n        cause = SIP.Utils.sipErrorCause(response.status_code);\n        this.emit('failed', response, cause);\n        break;\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  _DTMF.prototype.onRequestTimeout = function () {\n    this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n    this.owner.onRequestTimeout();\n  };\n  /**\n   * @private\n   */\n\n\n  _DTMF.prototype.onTransportError = function () {\n    this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n    this.owner.onTransportError();\n  };\n  /**\n   * @private\n   */\n\n\n  _DTMF.prototype.onDialogError = function (response) {\n    this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n    this.owner.onDialogError(response);\n  };\n  /**\n   * @private\n   */\n\n\n  _DTMF.prototype.init_incoming = function (request) {\n    this.direction = 'incoming';\n    this.request = request;\n    request.reply(200);\n\n    if (!this.tone || !this.duration) {\n      this.logger.warn('invalid INFO DTMF received, discarded');\n    } else {\n      this.owner.emit('dtmf', request, this);\n    }\n  };\n\n  _DTMF.C = C;\n  return _DTMF;\n};","map":null,"metadata":{},"sourceType":"script"}